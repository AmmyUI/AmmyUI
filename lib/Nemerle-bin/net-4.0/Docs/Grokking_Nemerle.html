<html><head>
  
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Nemerle Offline Documentation</title>
    <style type="text/css" media="screen,projection">
body {
    font: x-small sans-serif;
    background: #eee ;
    color: Black;
}
a {
    text-decoration: none;
    font-weight: bold;
    color: #25e;
    background: none;
}

a:visited { color: #63f/*#863*/; }
a:active { color: #ffa500; }
a:hover { text-decoration: underline; color: red; }

hr {
    height: 1px;
    color: #aaaaaa;
    background-color: #aaaaaa;
    border: 0;
    margin: 0.2em 0 0.2em 0;
}

h1, h2, h3, h4, h5, h6 {
    color: black;
    background: none;
    font-weight: bold;
    margin: 0;
    padding-top: 0.5em;
    padding-bottom: 0.17em;
    border-bottom: 1px solid #222;
}
h1 { font: bold 188% sans-serif; }
h2 { font: bold 150% sans-serif; }
h3 {
    border-bottom: 1px solid #aaa;
}
h4, h5, h6 {
    border-bottom: none;
}
h3 { font-size: 132%; }
h4 { font-size: 116%; }
h5 { font-size: 100%; }
h6 { font-size: 80%;  }

ul {
    line-height: 1.5em;
    list-style-type: square;
    margin: 0.3em 0 0 1.5em;
    padding:0;
}
ol {
    line-height: 1.5em;
    margin: 0.3em 0 0 3.2em;
    padding:0;
    list-style-image: none;
}
li { margin-bottom: 0.1em; }
dt {
    font-weight: bold;
    margin-bottom: 0.1em;
}
dl{
    margin-top: 0.2em;
    margin-bottom: 0.5em;
}
dd {
    line-height: 1.5em;
    margin-left: 2em;
    margin-bottom: 0.1em;
}
code { background-color: #f9f9f9; }
pre {
    padding: 1em;
    border: 1px dashed #2f6fab;
    color: Black;
    background-color: #f9f9f9;
    line-height: 1.1em;
}

#toc {
    /*border:1px solid #2f6fab;*/
    border:1px solid #aaaaaa;
    background-color:#f9f9f9;
    padding:5px;
    font-size: 95%;
    margin: 2em;
}
    </style>
  </head><body>


<a name="chunk-Grokking_Nemerle"></a>
	  	  <h1 class="firstHeading">Grokking Nemerle</h1>
	    	    	    <!-- start content -->
	    <div style="text-align: right;">
<p><i>"This is as rock; tolk in the True Speech."</i><br>
from <a href="http://en.wikipedia.org/wiki/A_Wizard_of_Earthsea" class="external text" title="http://en.wikipedia.org/wiki/A Wizard of Earthsea">A Wizard of Earthsea</a> by 
<a href="http://en.wikipedia.org/wiki/Ursula_K._Le_Guin" class="external text" title="http://en.wikipedia.org/wiki/Ursula K. Le Guin">Ursula K. Le Guin</a>
</p>
</div>
<a name="Don.27t_Panic.21"></a><h2> Don't Panic! </h2>
<p>This document contains materials used to teach Nemerle during the
"Nemerle Programming Language" course taught at our institute. It
should make a good tutorial. </p><p>There are references to various languages throughout this
document. If you don't know much about these languages -- just ignore
these remarks. As for remarks for the C language -- unless otherwise
stated they also apply to C# and Java.
</p><p>Some links: <a href="http://en.wikipedia.org/wiki/Grok" class="external text" title="http://en.wikipedia.org/wiki/Grok">grokking?!</a>, <a href="http://en.wikipedia.org/wiki/The_Hitchhiker%27s_Guide_to_the_Galaxy" class="external text" title="http://en.wikipedia.org/wiki/The Hitchhiker's Guide to the Galaxy">don't panic</a>.
</p>
<ol><li> <a href="#chunk-Grok_Base_structure_of_programs" title="Grok Base structure of programs">Grok Base structure of programs</a>
</li><li> <a href="#chunk-Grok_Namespaces" title="Grok Namespaces">Grok Namespaces</a>
</li><li> <a href="#chunk-Grok_Functionals" title="Grok Functionals">Grok Functionals</a>
</li><li> <a href="#chunk-Grok_Various_data_structures" title="Grok Various data structures">Grok Various data structures</a>
</li><li> <a href="#chunk-Grok_Variants_and_matching" title="Grok Variants and matching">Grok Variants and matching</a>
</li><li> <a href="#chunk-Grok_The_rest" title="Grok The rest">Grok The rest</a>
</li><li> <a href="#chunk-Grok_Object_oriented_programming" title="Grok Object oriented programming">Grok Object oriented programming</a>
</li><li> <a href="#chunk-Grok_Parametric_polymorphism" title="Grok Parametric polymorphism">Grok Parametric polymorphism</a>
</li><li> <a href="#chunk-Grok_Exceptions" title="Grok Exceptions">Grok Exceptions</a>
</li><li> <a href="#chunk-Grok_Properties%2C_indexers%2C_delegates_and_events" title="Grok Properties, indexers, delegates and events">Grok Properties, indexers, delegates and events</a>
</li></ol>

<!-- Saved in parser cache with key wiki:pcache:idhash:969-0!1!0!0!!en!2 and timestamp 20060121193025 -->
<a name="chunk-Grok_Base_structure_of_programs"></a>
	  	  <h1 class="firstHeading">Grok Base structure of programs</h1>
	    	    	    <!-- start content -->
	    <p>This page is a part of the <a href="#chunk-Grokking_Nemerle" title="Grokking Nemerle">Grokking Nemerle</a> tutorial.
</p><p>This chapter explains what a basic program looks like in Nemerle.
This is the longest and probably the hardest lesson, so don't worry
if you don't understand everything at once.
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Running_the_compiler"><span class="tocnumber">1</span> <span class="toctext">Running the compiler</span></a></li>
<li class="toclevel-1"><a href="#Methods"><span class="tocnumber">2</span> <span class="toctext">Methods</span></a></li>
<li class="toclevel-1"><a href="#Fields"><span class="tocnumber">3</span> <span class="toctext">Fields</span></a></li>
<li class="toclevel-1"><a href="#Expressions"><span class="tocnumber">4</span> <span class="toctext">Expressions</span></a></li>
<li class="toclevel-1"><a href="#A_simple_function"><span class="tocnumber">5</span> <span class="toctext">A simple function</span></a></li>
<li class="toclevel-1"><a href="#Imperative_loops_and_value_definitions"><span class="tocnumber">6</span> <span class="toctext">Imperative loops and value definitions</span></a></li>
<li class="toclevel-1"><a href="#Local_functions"><span class="tocnumber">7</span> <span class="toctext">Local functions</span></a></li>
<li class="toclevel-1"><a href="#Type_inference"><span class="tocnumber">8</span> <span class="toctext">Type inference</span></a></li>
<li class="toclevel-1"><a href="#External_functions"><span class="tocnumber">9</span> <span class="toctext">External functions</span></a>
<ul>
<li class="toclevel-2"><a href="#Output_formatting"><span class="tocnumber">9.1</span> <span class="toctext">Output formatting</span></a></li>
<li class="toclevel-2"><a href="#String_interpolation"><span class="tocnumber">9.2</span> <span class="toctext">String interpolation</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Arrays"><span class="tocnumber">10</span> <span class="toctext">Arrays</span></a>
<ul>
<li class="toclevel-2"><a href="#Type_enforcement_and_variants_of_if_expression"><span class="tocnumber">10.1</span> <span class="toctext">Type enforcement and variants of if expression</span></a></li>
<li class="toclevel-2"><a href="#Multidimensional_arrays"><span class="tocnumber">10.2</span> <span class="toctext">Multidimensional arrays</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Miscellaneous_information"><span class="tocnumber">11</span> <span class="toctext">Miscellaneous information</span></a></li>
<li class="toclevel-1"><a href="#Exercises_--_List_1"><span class="tocnumber">12</span> <span class="toctext">Exercises -- List 1</span></a></li>
</ul>
</td></tr></tbody></table>
<p><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
</p>
<a name="Running_the_compiler"></a><h2> Running the compiler </h2>
<p>In order to run programs written in Nemerle you need to compile them
to .NET bytecode first. This is done with the <tt>ncc</tt> (Nemerle
Compiler Compiler) command. Assuming the Nemerle is installed properly
on your system, you need to do the following:
</p>
<ul><li> write the program text with your favorite text editor and save it as a file with extension <tt>.n</tt>, for example <tt>myfile.n</tt>
</li><li> run the Nemerle compiler by typing <tt>ncc myfile.n</tt>
</li><li> the output goes to <tt>out.exe</tt>
</li><li> run it by typing <tt>out</tt> (Windows) or <tt>mono out.exe</tt> (Linux)
</li></ul>
<p>You cannot define either functions or values at the top level in
Nemerle. You need to pack them into <b>classes</b> or <b>modules</b>. For
C#, Java and C++ programmers: a module is a class with all members static,
there can be no instance of module class.
</p><p>For now you should consider the module to be a form of packing related
functions together.
</p>
<pre class="nemerle"><span style="color: rgb(255, 0, 0);">class</span> SomeClass
<span style="color: rgb(0, 0, 0);">{</span>
   <span style="color: rgb(0, 128, 128); font-style: italic;">//  ... some comment ...</span>
   some_field&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>;
&nbsp;
   <span style="color: rgb(0, 128, 128); font-style: italic;">/*  ... some ...
       ... multiline comment ... */</span> 
   other_field&nbsp;: <span style="color: rgb(255, 0, 0);">string</span>;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>The above example also introduces two kinds of <b>comments</b>  used in
Nemerle. The comments starting with <tt>//</tt> are active until the end
of line, while the comments starting with <tt>/*</tt> are active until
<tt>*/</tt>. This is the same as in C (well, C99).
</p>
<a name="Methods"></a><h2> Methods </h2>
<p><br>
Classes can contain <b>methods</b> (functions) as well as <b>fields</b>
(values). Both kind of members can be prefixed with access attributes:
</p>
<ul><li> <tt>public</tt> defines a method or a field that can be accessed from outside the module.
</li><li> <tt>private</tt> defines a member that is local to the module. This is the default.
</li><li> <tt>internal</tt> defines a member that is local to a given library or executable.
</li></ul>
<p>In the method declaration header you first write modifiers, then the name
of the method, then parameters with a type specification and finally a
type of values returned from this function.
</p><p>Typing constraints are in general written after a colon (:). 
</p>
<pre class="nemerle"><span style="color: rgb(255, 0, 0);">class</span> Foo
<span style="color: rgb(0, 0, 0);">{</span>
   <span style="color: rgb(6, 0, 255);">public</span> SomeMethod <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
   <span style="color: rgb(0, 0, 0);">{</span>
     <span style="color: rgb(0, 128, 128); font-style: italic;">//  ...</span>
   <span style="color: rgb(0, 0, 0);">}</span>
   <span style="color: rgb(6, 0, 255);">private</span> some_other_method <span style="color: rgb(0, 0, 0);">(</span>_x&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
   <span style="color: rgb(0, 0, 0);">{</span>
     <span style="color: rgb(0, 128, 128); font-style: italic;">//  ...</span>
   <span style="color: rgb(0, 0, 0);">}</span>
   <span style="color: rgb(6, 0, 255);">private</span> Frobnicate <span style="color: rgb(0, 0, 0);">(</span>_x&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>, _y&nbsp;: <span style="color: rgb(255, 0, 0);">string</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>
   <span style="color: rgb(0, 0, 0);">{</span>
     <span style="color: rgb(0, 128, 128); font-style: italic;">//  we return some int value here</span>
     <span style="color: rgb(255, 0, 0);">0</span>
   <span style="color: rgb(0, 0, 0);">}</span>
   <span style="color: rgb(6, 0, 255);">internal</span> foo_bar <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
   <span style="color: rgb(0, 0, 0);">{</span>
     <span style="color: rgb(0, 128, 128); font-style: italic;">//  ...</span>
   <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<a name="Fields"></a><h2> Fields </h2>
<p>Fields define global values inside the module.
</p><p>Fields accept the same access attributes as methods. However, there is
one additional very important attribute for fields -- <tt>mutable</tt>.
</p><p>By default fields are read only, that is they can be assigned values
only in the module initializer function (codenamed this; we will talk
about it later). If you want to assign values to fields in other places
you need to mark a field <tt>mutable</tt>.
</p>
<pre class="nemerle"><span style="color: rgb(255, 0, 0);">class</span> Bar
<span style="color: rgb(0, 0, 0);">{</span>
   <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">mutable</span> qux&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>;
   <span style="color: rgb(6, 0, 255);">private</span> quxx&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>;
   <span style="color: rgb(6, 0, 255);">mutable</span> bar&nbsp;: <span style="color: rgb(255, 0, 0);">float</span>;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<a name="Expressions"></a><h2> Expressions </h2>
<p>Nemerle makes no distinction between an expression and a statement, there
are only expressions. The idea is to easily operate on values, which every expression 
returns as a result of its computation. The exception is a <tt>throw</tt> keyword, 
which breaks control flow by throwing an exception (the breaking statements were adopted in Nemerle using the <a href="http://wiki.nemerle.org/Block" title="Block">block</a> construct, which makes jumps localised and fit well into the expressions-only concept). 
</p><p>Also <b>{ }</b> sequence is an expression, which have its value - the value of the last expression in it.
This eliminates the need for <tt>return</tt> statement in functions. The value returned from a
function is the last value computed in its body. You can think that there is an implicit <tt>return</tt> at the
end of each function. This is the same as in ML languages.
</p><p>Despite all that, the most basic example looks almost like in C#. The
entry point for a program is a function called <tt>Main</tt>. It is also
possible to take command line arguments and/or return integer return
code from the Main method, consult .NET reference for details.
</p><p>Note that unlike in ML function call requires <tt>()</tt>.
</p>
<pre class="nemerle"><span style="color: rgb(255, 0, 0);">class</span> Hello
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">static</span> Main <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(0, 0, 0);">System</span>.Console.WriteLine <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"Hello cruel world!"</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<a name="A_simple_function"></a><h2> A simple function </h2>
<p>However, the following example (computing
<a href="http://en.wikipedia.org/wiki/Fibonacci_number" class="external text" title="http://en.wikipedia.org/wiki/Fibonacci number">Fibonacci sequence</a>)
looks somewhat different. You can see the usage of a <b>conditional expression</b>. 
Note how the value is returned from the function without
any explicit return statement.
</p><p>Note that this example and the following ones are not complete. To be
compiled they need to be packed into the module, equipped with the Main
function and so on.
</p>
<pre class="nemerle">fib <span style="color: rgb(0, 0, 0);">(</span>n&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>
<span style="color: rgb(0, 0, 0);">{</span>
   <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>n &lt; <span style="color: rgb(255, 0, 0);">2</span><span style="color: rgb(0, 0, 0);">)</span>
     <span style="color: rgb(255, 0, 0);">1</span>
   <span style="color: rgb(6, 0, 255);">else</span>
     fib <span style="color: rgb(0, 0, 0);">(</span>n - <span style="color: rgb(255, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">)</span> + fib <span style="color: rgb(0, 0, 0);">(</span>n - <span style="color: rgb(255, 0, 0);">2</span><span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<a name="Imperative_loops_and_value_definitions"></a><h2> Imperative loops and value definitions </h2>
<p>It is possible to use regular <b>imperative loops</b> like <tt>while</tt> and
<tt>for</tt>. Both work as in C. In the example of the <tt>for</tt> loop the first expression is
put before the loop, the second expression is the condition (the loop
is executed as long as the condition holds) and the last expression is
put at the end of the loop.
</p><p>However, the most important thing about this example is the variable
definition used here. <b>Variables</b> (values that can be changed) are
defined using the <tt>mutable</tt> expression. You do not specify a type, but you do
specify an initial value. The type of the defined variable is inferred from
the initial value (for example the type of <tt>1</tt> is obviously an
<tt>int</tt>). The variable introduced with <tt>mutable</tt> is visible
until the end of the current sequence. Lexical scoping rules apply:
the definition of a new value with the same name hides the previous one.
</p><p><b>Sequence</b> is a list of expressions enclosed in braces (<tt>{}</tt>)
and separated with semicolons (<tt>;</tt>). An optional semicolon is
allowed at the end of the sequence. Note that the function definition also
introduces a sequence (as the function body is written in <tt>{}</tt>).
</p><p><tt>mutable</tt> defines <b>variables</b> that can be updated using
the assignment operator (<tt>=</tt>). In contrast <tt>def</tt> defines
<b>values</b> that cannot be updated -- in our example we use <tt>tmp</tt>
as such value.
</p><p>Older versions of the Nemerle compiler required a semicolon after the
closing brace inside a sequence. This is no longer mandatory: note that
for expression's closing brace is not followed by a semicolon. In some
rare cases this can introduce compilation errors -- remember that you
can always put a semicolon there!
</p>
<pre class="nemerle">fib <span style="color: rgb(0, 0, 0);">(</span>n&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>
<span style="color: rgb(0, 0, 0);">{</span>
   <span style="color: rgb(6, 0, 255);">mutable</span> last1 = <span style="color: rgb(255, 0, 0);">1</span>;
   <span style="color: rgb(6, 0, 255);">mutable</span> last2 = <span style="color: rgb(255, 0, 0);">1</span>;
&nbsp;
   <span style="color: rgb(6, 0, 255);">for</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(6, 0, 255);">mutable</span> cur = <span style="color: rgb(255, 0, 0);">1</span>; cur &lt; n; ++cur<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
     <span style="color: rgb(6, 0, 255);">def</span> tmp = last1 + last2;
     last1 = last2;
     last2 = tmp;
   <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
   last2
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>In this example we see no gain from using <tt>def</tt>. instead
of <tt>int</tt> as you would do in C# (both are 3 characters long&nbsp;:-). 
However, in most cases type names are far longer. For example:
</p>
<pre class="nemerle">FooBarQuxxFactory fact = <span style="color: rgb(0, 128, 0);">new</span> FooBarQuxxFactory <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>; <span style="color: rgb(0, 128, 128); font-style: italic;">// C#</span>
<span style="color: rgb(6, 0, 255);">def</span> fact = FooBarQuxxFactory <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>; <span style="color: rgb(0, 128, 128); font-style: italic;">// Nemerle</span></pre>
<a name="Local_functions"></a><h2> Local functions </h2>
<p>Local functions are functions defined within other functions. For this
reason they are also called <b>nested functions</b>.
</p><p>There are three reasons for defining local functions. The first one
is not to pollute the class namespace. We have the <tt>private</tt>
keyword for that, so this does not seem to be any good reason.
</p><p>The second one is that local functions can access variables defined in
an outer function. This allows for somewhat different (better?) code
structuring than in C. You can have several variables and local functions
using them defined in a function.
</p><p>The most important reason for local function is however the fact that
you can pass them to other functions so that they can be run from there,
implementing for example iterators for data structures. This is explained
in more detail <a href="#chunk-Grok_Functionals" title="Grok Functionals">later</a>.
</p><p>Local functions are defined just like other values with the def keyword. A
local function definition looks similar to the global one (despite the
lack of access modifiers, leading def and the trailing semicolon).
</p>
<pre class="nemerle">sum_cubes <span style="color: rgb(0, 0, 0);">(</span>v1&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>, v2&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>, v3&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>
<span style="color: rgb(0, 0, 0);">{</span>
   <span style="color: rgb(6, 0, 255);">def</span> cube <span style="color: rgb(0, 0, 0);">(</span>x&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span> <span style="color: rgb(0, 0, 0);">{</span>
     x * x * x
   <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
   cube <span style="color: rgb(0, 0, 0);">(</span>v1<span style="color: rgb(0, 0, 0);">)</span> + cube <span style="color: rgb(0, 0, 0);">(</span>v2<span style="color: rgb(0, 0, 0);">)</span> + cube <span style="color: rgb(0, 0, 0);">(</span>v3<span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>Using local functions is one of way of implementing loops in Nemerle.
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">module</span> Sum <span style="color: rgb(0, 0, 0);">{</span>
   <span style="color: rgb(6, 0, 255);">public</span> Main <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
   <span style="color: rgb(0, 0, 0);">{</span>
     <span style="color: rgb(6, 0, 255);">def</span> sum <span style="color: rgb(0, 0, 0);">(</span>x&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span> <span style="color: rgb(0, 0, 0);">{</span>
       <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>x &lt;= <span style="color: rgb(255, 0, 0);">0</span><span style="color: rgb(0, 0, 0);">)</span>
         <span style="color: rgb(255, 0, 0);">0</span>
       <span style="color: rgb(6, 0, 255);">else</span>
         x + sum <span style="color: rgb(0, 0, 0);">(</span>x - <span style="color: rgb(255, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">)</span>
     <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
     <span style="color: rgb(0, 0, 0);">System</span>.Console.WriteLine <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"Sum of numbers from "</span>+
                               <span style="color: rgb(128, 128, 128);">"20 to 0 is: {0}"</span>, sum <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">20</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
   <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>Notice how the local function is used to organize the loop. This is
typical for Nemerle. It is therefore quite important for you to grok
this concept. Some external links -- <a href="http://en.wikipedia.org/wiki/Tail_recursion" class="external text" title="http://en.wikipedia.org/wiki/Tail recursion">tail recursion</a>, <a href="http://en.wikipedia.org/wiki/Recursion" class="external text" title="http://en.wikipedia.org/wiki/Recursion">recursion</a>.
</p><p>Here goes another example of a loop constructed with a local function.
</p>
<pre class="nemerle">fib <span style="color: rgb(0, 0, 0);">(</span>n&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>
<span style="color: rgb(0, 0, 0);">{</span>
   <span style="color: rgb(6, 0, 255);">def</span> my_loop <span style="color: rgb(0, 0, 0);">(</span>last1&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>, last2&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>, cur&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span> <span style="color: rgb(0, 0, 0);">{</span>
     <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>cur &gt;= n<span style="color: rgb(0, 0, 0);">)</span>
       last2
     <span style="color: rgb(6, 0, 255);">else</span>
       my_loop <span style="color: rgb(0, 0, 0);">(</span>last2, last1 + last2, cur + <span style="color: rgb(255, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">)</span>
   <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
   my_loop <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">1</span>, <span style="color: rgb(255, 0, 0);">1</span>, <span style="color: rgb(255, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>If you are concerned about performance of such form of writing loops --
fear you not. When the function body ends with a call to another function
-- no new stack frame is created. It is called a <b>tail call</b>. Thanks to
it the example above is as efficient as the for loop we have seen before.
</p>
<a name="Type_inference"></a><h2> Type inference </h2>
<p>You can specify types of parameters as well as return types for local
functions. However in some (most?) cases the compiler can guess (infer)
the types for you, so you can save your fingers by not typing them. This
is always safe, that is the program should not in principle change the
meaning if type annotations are added.
</p><p>Sometimes the compiler is unable to safely infer the type information, 
in which case an error message will be generated to indicate that 
type annotations are required.
</p><p>In the following example we have omitted the return type, as well as
types of the parameters. Compiler can figure out the types, because
literals <tt>1</tt> are used in a few places, which are of the type
<tt>int</tt>.
</p>
<pre class="nemerle">fib <span style="color: rgb(0, 0, 0);">(</span>n&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>
<span style="color: rgb(0, 0, 0);">{</span>
   <span style="color: rgb(6, 0, 255);">def</span> my_loop <span style="color: rgb(0, 0, 0);">(</span>last1, last2, cur<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
     <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>cur &gt;= n<span style="color: rgb(0, 0, 0);">)</span>
       last2
     <span style="color: rgb(6, 0, 255);">else</span>
       my_loop <span style="color: rgb(0, 0, 0);">(</span>last2, last1 + last2, cur + <span style="color: rgb(255, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">)</span>
   <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
   my_loop <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">1</span>, <span style="color: rgb(255, 0, 0);">1</span>, <span style="color: rgb(255, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<a name="External_functions"></a><h2> External functions </h2>
<p>One of the best things about Nemerle is that you can use rich class
libraries that come with the Framework as well as the third party
libraries. Links to the documentation about .NET class libraries
<a href="http://wiki.nemerle.org/Class_library" title="Class library">can be found here</a>.
</p><p>New objects are constructed by simply naming the type and supplying
arguments to its constructor. Note that unlike in C# or Java you don't use
the <tt>new</tt> keyword to construct new objects. Methods of objects can
be invoked later, using the dot operator (<tt>some_object.SomeMethod
(some_argument)</tt>). Static methods are invoked using the
<tt>NameSpace.TypeName.MethodName ()</tt> syntax. We will talk more
about this object oriented stuff later.
</p><p>Now some example:
</p>
<pre class="nemerle">the_answer_to_the_universe <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>
<span style="color: rgb(0, 0, 0);">{</span>
   <span style="color: rgb(0, 128, 128); font-style: italic;">// Construct new random number generator.</span>
   <span style="color: rgb(0, 128, 128); font-style: italic;">// This is object construction, explained in more detail later</span>
   <span style="color: rgb(6, 0, 255);">def</span> r = <span style="color: rgb(0, 0, 0);">System</span>.Random <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
&nbsp;
   <span style="color: rgb(0, 128, 128); font-style: italic;">// Return new random number from [0, 99] range.</span>
   <span style="color: rgb(0, 128, 128); font-style: italic;">// This is again object invocation, explained later</span>
   r.Next <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">100</span><span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>For more information about <i>The answer to the Ultimate Question of Life, the Universe and Everything</i> please visit <a href="http://en.wikipedia.org/wiki/The_Answer_to_Life,_the_Universe,_and_Everything" class="external text" title="http://en.wikipedia.org/wiki/The Answer to Life, the Universe, and Everything">this site</a>. Please note that
this program run on a computer not as powerful as Deep Thought will be
right only in 1% of cases.
</p>
<a name="Output_formatting"></a><h3> Output formatting </h3>
<p>There are several methods of output formatting in Nemerle.
</p><p>The most basic .NET methods of displaying stuff on the screen is the
<tt>System.Console.WriteLine</tt> method. In the simplest form it takes
a string to be displayed. If you however supply it with more then one
argument, the first one is treated as a format string and occurrences of
<tt>{N}</tt> are replaced with the value of (N+2)-th parameter (counting
from one).
</p>
<pre class="nemerle">print_answer <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">def</span> the_answer = the_answer_to_the_universe <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(0, 0, 0);">System</span>.Console.WriteLine <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"The answer to the Ultimate "</span>+
                            <span style="color: rgb(128, 128, 128);">"Question of Life, the "</span>+
                            <span style="color: rgb(128, 128, 128);">"Universe and Everything "</span>+
                            <span style="color: rgb(128, 128, 128);">"is {0}"</span>, the_answer<span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>There are however other means, for example the
<tt>Nemerle.IO.printf</tt> macro that works much like
the <tt>printf(3)</tt> C function or <tt>Printf.printf</tt> in OCaml.
(Well it doesn't yet handle most formatting modifiers, but patches are
welcome&nbsp;;-)
</p>
<pre class="nemerle">printf_answer <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">def</span> the_answer = the_answer_to_the_universe <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(0, 0, 0);">Nemerle</span>.IO.printf <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"The answer is %d<span style="color: rgb(0, 128, 128); font-weight: bold;">\n</span>"</span>, the_answer<span style="color: rgb(0, 0, 0);">)</span>;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<a name="String_interpolation"></a><h3> String interpolation </h3>
<p>If you have ever programmed in Bourne shell, perl, python, php (or some other
P-language), you know about string interpolation. It basically takes
a string <tt>"answer is $the_answer"</tt> and replaces <tt>$the_answer</tt>
with value of the variable <tt>the_answer</tt>. The good news is that
we have this feature in Nemerle:
</p>
<pre class="nemerle">interpolate_answer <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">def</span> the_answer = the_answer_to_the_universe <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(0, 0, 0);">Nemerle</span>.IO.print <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"The answer is $the_answer<span style="color: rgb(0, 128, 128); font-weight: bold;">\n</span>"</span><span style="color: rgb(0, 0, 0);">)</span>;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>It comes in two flavors -- the first one is the <tt>Nemerle.IO.print</tt>
(without f) function -- it does string interpolation on its sole argument
and prints the result on stdout.
</p><p>The second version is the <tt>$</tt> operator, which returns a string
and can be used with other printing mechanisms:
</p>
<pre class="nemerle">interpolate2_answer <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">def</span> the_answer = the_answer_to_the_universe <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(0, 0, 0);">System</span>.Console.WriteLine <span style="color: rgb(0, 0, 0);">(</span>$ <span style="color: rgb(128, 128, 128);">"The answer is $the_answer"</span><span style="color: rgb(0, 0, 0);">)</span>;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>Both versions support special <tt>$(...)</tt> quotations allowing
any code to be expanded, not just variable references:
</p>
<pre class="nemerle">interpolate3_answer <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(0, 0, 0);">System</span>.Console.WriteLine <span style="color: rgb(0, 0, 0);">(</span>
    $ <span style="color: rgb(128, 128, 128);">"The answer is $(the_answer_to_the_universe ())"</span><span style="color: rgb(0, 0, 0);">)</span>;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>The $-expansion works on all types.
</p>
<a name="Arrays"></a><h2> Arrays </h2>
<p>The type of array of <tt>T</tt> is denoted <tt>array [T]</tt>. This is
a one-dimensional, zero-based array. There are two special expressions
for constructing new arrays: <tt>array ["foo", "bar", "baz"]</tt>
will construct a 3-element array of strings, while <tt>array (100)</tt>
creates a 100-element array of something. The <i>something</i> is inferred
later, based on an array usage. The empty array is initialized with <tt>0</tt>,
<tt>0.0</tt>, etc. or <tt>null</tt> for reference types.
</p><p>The assignment operator (<tt>=</tt>) can be also used to assign elements
in arrays.
</p><p>Note the <tt>ar.Length</tt> expression -- it gets the length of array
<tt>ar</tt>. It looks like a field reference in an array object but
under the hood it is a method call. This mechanism is called <i>property</i>.
</p><p>Our arrays are subtypes of <tt>System.Array</tt>, so all methods available
for <tt>System.Array</tt> are also available for <tt>array [T]</tt>.
</p>
<pre class="nemerle"> <span style="color: rgb(255, 0, 0);">class</span> ArraysTest <span style="color: rgb(0, 0, 0);">{</span>
   <span style="color: rgb(6, 0, 255);">static</span> reverse_array <span style="color: rgb(0, 0, 0);">(</span>ar&nbsp;: <span style="color: rgb(6, 0, 255);">array</span> <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
   <span style="color: rgb(0, 0, 0);">{</span>
     <span style="color: rgb(6, 0, 255);">def</span> loop <span style="color: rgb(0, 0, 0);">(</span>left, right<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
       <span style="color: rgb(6, 0, 255);">when</span> <span style="color: rgb(0, 0, 0);">(</span>left &lt; right<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
         <span style="color: rgb(6, 0, 255);">def</span> tmp = ar<span style="color: rgb(0, 0, 0);">[</span>left<span style="color: rgb(0, 0, 0);">]</span>;
         ar<span style="color: rgb(0, 0, 0);">[</span>left<span style="color: rgb(0, 0, 0);">]</span> = ar<span style="color: rgb(0, 0, 0);">[</span>right<span style="color: rgb(0, 0, 0);">]</span>;
         ar<span style="color: rgb(0, 0, 0);">[</span>right<span style="color: rgb(0, 0, 0);">]</span> = tmp;
         loop <span style="color: rgb(0, 0, 0);">(</span>left + <span style="color: rgb(255, 0, 0);">1</span>, right - <span style="color: rgb(255, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">)</span>
       <span style="color: rgb(0, 0, 0);">}</span>
     <span style="color: rgb(0, 0, 0);">}</span>
     loop <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">0</span>, ar.Length - <span style="color: rgb(255, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">)</span>
   <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
   <span style="color: rgb(6, 0, 255);">static</span> print_array <span style="color: rgb(0, 0, 0);">(</span>ar&nbsp;: <span style="color: rgb(6, 0, 255);">array</span> <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
   <span style="color: rgb(0, 0, 0);">{</span>
     <span style="color: rgb(6, 0, 255);">for</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(6, 0, 255);">mutable</span> i = <span style="color: rgb(255, 0, 0);">0</span>; i &lt; ar.Length; ++i<span style="color: rgb(0, 0, 0);">)</span>
       <span style="color: rgb(0, 0, 0);">Nemerle</span>.IO.printf <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"%d<span style="color: rgb(0, 128, 128); font-weight: bold;">\n</span>"</span>, ar<span style="color: rgb(0, 0, 0);">[</span>i<span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span>
   <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
   <span style="color: rgb(6, 0, 255);">static</span> Main <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
   <span style="color: rgb(0, 0, 0);">{</span>
     <span style="color: rgb(6, 0, 255);">def</span> ar = <span style="color: rgb(6, 0, 255);">array</span> <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">1</span>, <span style="color: rgb(255, 0, 0);">42</span>, <span style="color: rgb(255, 0, 0);">3</span><span style="color: rgb(0, 0, 0);">]</span>;
     print_array <span style="color: rgb(0, 0, 0);">(</span>ar<span style="color: rgb(0, 0, 0);">)</span>;
     <span style="color: rgb(0, 0, 0);">Nemerle</span>.IO.printf <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"<span style="color: rgb(0, 128, 128); font-weight: bold;">\n</span>"</span><span style="color: rgb(0, 0, 0);">)</span>;
     reverse_array <span style="color: rgb(0, 0, 0);">(</span>ar<span style="color: rgb(0, 0, 0);">)</span>;
     print_array <span style="color: rgb(0, 0, 0);">(</span>ar<span style="color: rgb(0, 0, 0);">)</span>;
   <span style="color: rgb(0, 0, 0);">}</span>
 <span style="color: rgb(0, 0, 0);">}</span></pre>
<a name="Type_enforcement_and_variants_of_if_expression"></a><h3> Type enforcement and variants of <tt>if</tt> expression </h3>
<p>One interesting thing about this example is the usage of the type
enforcement operator -- colon (<tt>:</tt>). We use it to enforce the
<tt>left</tt> type to be <tt>int</tt>. We could have as well written
<tt>def loop (left&nbsp;: int, right) {</tt>. This are simply two ways to
achieve the same thing.
</p><p>Another interesting thing is the <tt>when</tt> expression -- it is an
<tt>if</tt> without else. For symmetry purposes we also have <tt>if</tt>
without then called <tt>unless</tt>. As you might have already noted
<tt>unless</tt> is equivalent to <tt>when</tt> with the condition negated.
</p><p>In Nemerle the <tt>if</tt> expression always needs to have the
<tt>else</tt> clause. It's done this way to avoid stupid bugs with a
dangling <tt>else</tt>
</p>
<pre class="csharp"><span style="color: rgb(0, 128, 128); font-style: italic;">// C#, misleading indentation hides real code meaning</span>
<span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>foo<span style="color: rgb(0, 0, 0);">)</span>
   <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>bar<span style="color: rgb(0, 0, 0);">)</span>
     m1 <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
<span style="color: rgb(6, 0, 255);">else</span>
   m2 <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;</pre>
<p>If you do not want the <tt>else</tt> clause, use <tt>when</tt> expression,
as seen in the example.
</p><p><br>
</p>
<a name="Multidimensional_arrays"></a><h3> Multidimensional arrays </h3>
<p>Multidimensional arrays (unlike arrays of arrays) are also available. Type
of two-dimensional integer array is <tt>array [2, int]</tt>, while the
expression constructing it is <tt>array .[2] [[1, 2], [3, 4]]</tt>. They
are accessed using the comma-syntax: <tt>t[1,0]</tt>.
</p><p>Both single- and multidimensional empty arrays can be created with
<tt>array (size)</tt> or <tt>array (size1, size2, ...)</tt>. Empty means
that they contain nulls or zeros.
</p><p>Note that there exist two ways of obtaining multidimensional storage. The first one is 
the mentioned multidimentional array (type <tt>array [<i>N</i>, int]</tt>). The second one is array of arrays  
(type <tt>array [array [int]]</tt>), which is just a standard array, but its elements are other arrays. 
This is useful, because you can initialize only some parts of this array, while multidimensional 
array allocates all the memory at once. Elements of such a array of arrays are accessed by <tt>x[2][3]</tt>.
</p>
<a name="Miscellaneous_information"></a><h2> Miscellaneous information </h2>
<p>The equality predicate is written <tt>==</tt> and the inequality is
<tt>!=</tt> as in C.
</p><p>The boolean operators (<tt>&amp;&amp;</tt>, <tt>||</tt> and <tt>!</tt>) are all
available and work the same as in C.
</p>
<a name="Exercises_--_List_1"></a><h2> Exercises -- List 1 </h2>
<p><b>1.1.</b> Write a program that prints out to the console:
</p>
<pre>1 bottle of beer.
2 bottles of beer.
3 bottles of beer.
...
99 bottles of beer.
</pre>
<p>With an appropriate amount of beer instead of <tt>...</tt>. The program source
code should not exceed 30 lines.
</p><p><b>1.2.</b> Implement <a href="http://www.catb.org/%7Eesr/jargon/html/B/bogo-sort.html" class="external text" title="http://www.catb.org/~esr/jargon/html/B/bogo-sort.html">bogo sort</a> 
algorithm for an array of integers. (WARNING:
you should not implement <i>destroy the universe</i> step). Test it by
sorting the following array: <tt>[4242, 42, -42, 31415]</tt>.
</p><p><b>1.3.</b> As 1.2, but don't use the imperative loops -- rewrite them with recursion.
</p>
<!-- Saved in parser cache with key wiki:pcache:idhash:970-0!1!0!0!!en!2 and timestamp 20060121190356 -->
<a name="chunk-Grok_Namespaces"></a>
	  	  <h1 class="firstHeading">Grok Namespaces</h1>
	    	    	    <!-- start content -->
	    <p>This page is a part of the <a href="#chunk-Grokking_Nemerle" title="Grokking Nemerle">Grokking Nemerle</a> tutorial.
</p>
<a name="Namespaces"></a><h2> Namespaces </h2>
<p>Classes and modules can be put in namespaces. Namespaces at the conceptual
level prepend a string to names of objects defined within them.
</p>
<pre class="nemerle"> <span style="color: rgb(6, 0, 255);">namespace</span> Deep.Thought
 <span style="color: rgb(0, 0, 0);">{</span>
   <span style="color: rgb(255, 0, 0);">class</span> Answer
   <span style="color: rgb(0, 0, 0);">{</span>
     <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">static</span> Get <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>
     <span style="color: rgb(0, 0, 0);">{</span>
       <span style="color: rgb(255, 0, 0);">42</span>
     <span style="color: rgb(0, 0, 0);">}</span>
   <span style="color: rgb(0, 0, 0);">}</span>
 <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
 <span style="color: rgb(6, 0, 255);">namespace</span> Loonquawl
 <span style="color: rgb(0, 0, 0);">{</span>
   <span style="color: rgb(255, 0, 0);">class</span> Brain
   <span style="color: rgb(0, 0, 0);">{</span>
     <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">static</span> Run <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
     <span style="color: rgb(0, 0, 0);">{</span>
       <span style="color: rgb(0, 0, 0);">System</span>.Console.WriteLine <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"The answer {0}"</span>,
                                 Deep.Thought.Answer.Get <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
     <span style="color: rgb(0, 0, 0);">}</span>
   <span style="color: rgb(0, 0, 0);">}</span>
 <span style="color: rgb(0, 0, 0);">}</span></pre>
<p>As you can see, the name of the <tt>Get</tt> function is first
prepended with the name of the module (<tt>Answer</tt>) and then with
the current namespace (<tt>Deep.Thought</tt>), forming its full name:
<tt>Deep.Thought.Answer.Get</tt>.
</p><p>Another example is the <tt>WriteLine</tt> method of the <tt>Console</tt>
module, defined in the <tt>System</tt> namespace.
</p>
<a name="Making_long_names_short"></a><h2> Making long names short </h2>
<p>In order not to write <tt>System.Console.WriteLine</tt> or
<tt>Deep.Thought.Answer.Get</tt> all the time you can import all
declarations from the specified namespace into the current scope with
the <tt>using</tt> directive.
</p><p>Thus the <tt>Loonquawl.Brain</tt> module from the example above could be:
</p>
<pre class="nemerle"> <span style="color: rgb(6, 0, 255);">namespace</span> LoonquawlUsing
 <span style="color: rgb(0, 0, 0);">{</span>
   <span style="color: rgb(6, 0, 255);">using</span> <span style="color: rgb(0, 0, 0);">System</span>.Console;
   <span style="color: rgb(6, 0, 255);">using</span> Deep.Thought.Answer;
&nbsp;
   <span style="color: rgb(255, 0, 0);">class</span> Brain
   <span style="color: rgb(0, 0, 0);">{</span>
     <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">static</span> Run <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
     <span style="color: rgb(0, 0, 0);">{</span>
       WriteLine <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"The answer is {0}"</span>, Get <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
     <span style="color: rgb(0, 0, 0);">}</span>
   <span style="color: rgb(0, 0, 0);">}</span>
 <span style="color: rgb(0, 0, 0);">}</span></pre>
<p>While we see not much gain from the using directive in this example,
it can be handy when you use the <tt>WriteLine</tt> method 100 times,
and/or your classes are in <tt>Some.Very.Long.Namespaces</tt>.
</p><p>Note that unlike in C# all methods of a class can be imported into the
current namespace. Thus, <tt>using</tt> is not limited to namespaces, but it
also works for classes. The new thing is also the fact, that currently
opened namespaces are used as prefix in all type lookups - for example
if there is <tt>using System;</tt>, then you can write 
<tt>Xml.XmlDocument ()</tt>, or with an additional <tt>using System.Xml;</tt>
you can write <tt>XmlDocument ()</tt>. Neither of these is possible in C#.
</p><p>It is also possible to create (shorter) aliases for namespaces and
types. It is sometimes useful in case when two namespaces share several
types, so they cannot be imported with <tt>using</tt> simultaneously. This
works in similar way to C#.
</p>
<pre class="nemerle"> <span style="color: rgb(6, 0, 255);">namespace</span> LoonquawlAlias
 <span style="color: rgb(0, 0, 0);">{</span>
   <span style="color: rgb(6, 0, 255);">using</span> SC = <span style="color: rgb(0, 0, 0);">System</span>.Console;
   <span style="color: rgb(6, 0, 255);">using</span> DTA = Deep.Thought.Answer;
&nbsp;
   <span style="color: rgb(255, 0, 0);">class</span> Brain
   <span style="color: rgb(0, 0, 0);">{</span>
     <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">static</span> Run <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
     <span style="color: rgb(0, 0, 0);">{</span>
       SC.WriteLine <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"The answer is {0}"</span>, DTA.Get <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
     <span style="color: rgb(0, 0, 0);">}</span>
   <span style="color: rgb(0, 0, 0);">}</span>
 <span style="color: rgb(0, 0, 0);">}</span></pre>

<!-- Saved in parser cache with key wiki:pcache:idhash:971-0!1!0!0!!en!2 and timestamp 20060121193028 -->
<a name="chunk-Grok_Functionals"></a>
	  	  <h1 class="firstHeading">Grok Functionals</h1>
	    	    	    <!-- start content -->
	    <p>This page is a part of the <a href="#chunk-Grokking_Nemerle" title="Grokking Nemerle">Grokking Nemerle</a> tutorial.
</p>
<a name="Functional_values"></a><h2> Functional values </h2>
<p>In Nemerle you can pass functions as arguments of other functions, as
well as return them as results. This way functions are not worse than
any other data types (think about Equal Rights for Functions movement&nbsp;:-)
</p><p>In C# there are delegates. This concept is quite similar to
functional values. However, functional values are far more efficient
and their types need not be declared before use.
</p><p>As a first example consider:
</p>
<pre class="csharp"><span style="color: rgb(0, 128, 128); font-style: italic;">// C#</span>
<span style="color: rgb(255, 0, 0);">delegate</span> <span style="color: rgb(255, 0, 0);">int</span> IntFun <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>;
&nbsp;
<span style="color: rgb(255, 0, 0);">class</span> Delegates <span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">static</span> <span style="color: rgb(255, 0, 0);">int</span> f<span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">int</span> x<span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">return</span> x * <span style="color: rgb(255, 0, 0);">2</span>;
  <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
  <span style="color: rgb(6, 0, 255);">static</span> <span style="color: rgb(255, 0, 0);">int</span> run_delegate_twice<span style="color: rgb(0, 0, 0);">(</span>IntFun f, <span style="color: rgb(255, 0, 0);">int</span> v<span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">return</span> f<span style="color: rgb(0, 0, 0);">(</span>f<span style="color: rgb(0, 0, 0);">(</span>v<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(0, 0, 0);">}</span>
  
  <span style="color: rgb(6, 0, 255);">static</span> <span style="color: rgb(6, 0, 255);">void</span> Main <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(0, 0, 0);">System</span>.<span style="color: rgb(0, 0, 255);">Console</span>.<span style="color: rgb(0, 0, 255);">WriteLine</span><span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"{0}"</span>, 
                   run_delegate_twice<span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 128, 0);">new</span> IntFun <span style="color: rgb(0, 0, 0);">(</span>f<span style="color: rgb(0, 0, 0);">)</span>, <span style="color: rgb(255, 0, 0);">3</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<pre class="nemerle"> <span style="color: rgb(0, 128, 128); font-style: italic;">//  Nemerle</span>
 <span style="color: rgb(255, 0, 0);">class</span> Functions <span style="color: rgb(0, 0, 0);">{</span>
   <span style="color: rgb(6, 0, 255);">static</span> f <span style="color: rgb(0, 0, 0);">(</span>x&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>
   <span style="color: rgb(0, 0, 0);">{</span>
     x * <span style="color: rgb(255, 0, 0);">2</span>
   <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
   <span style="color: rgb(6, 0, 255);">static</span> run_funval_twice <span style="color: rgb(0, 0, 0);">(</span>f&nbsp;: <span style="color: rgb(255, 0, 0);">int</span> -&gt; <span style="color: rgb(255, 0, 0);">int</span>, v&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>
   <span style="color: rgb(0, 0, 0);">{</span>
     f <span style="color: rgb(0, 0, 0);">(</span>f <span style="color: rgb(0, 0, 0);">(</span>v<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
   <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
   <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">static</span> Run <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
   <span style="color: rgb(0, 0, 0);">{</span>
     <span style="color: rgb(0, 0, 0);">System</span>.Console.WriteLine <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"{0}"</span>, run_funval_twice <span style="color: rgb(0, 0, 0);">(</span>f, <span style="color: rgb(255, 0, 0);">3</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
   <span style="color: rgb(0, 0, 0);">}</span>
 <span style="color: rgb(0, 0, 0);">}</span></pre>
<p>In this example delegates seem just like function pointers in
C. Functional values do not appear any better, except maybe for the
shorter syntax. However, the real power of delegates comes from the fact
that methods can be used as delegates (thus effectively embedding the
this pointer in the delegate). This is much like "functional objects"
design pattern in C++. We will not show it here, please refer to the C#
manual for details.
</p><p>Still using methods as delegates does not demonstrate their full
power. The funny part begins when we use nested functions as functional
values.
</p>
<pre class="nemerle"> <span style="color: rgb(255, 0, 0);">class</span> MoreFunctions <span style="color: rgb(0, 0, 0);">{</span>
   <span style="color: rgb(6, 0, 255);">static</span> run_twice <span style="color: rgb(0, 0, 0);">(</span>f&nbsp;: <span style="color: rgb(255, 0, 0);">int</span> -&gt; <span style="color: rgb(255, 0, 0);">int</span>, v&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>
   <span style="color: rgb(0, 0, 0);">{</span>
     f <span style="color: rgb(0, 0, 0);">(</span>f <span style="color: rgb(0, 0, 0);">(</span>v<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
   <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
   <span style="color: rgb(6, 0, 255);">static</span> run_adder <span style="color: rgb(0, 0, 0);">(</span>x&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
   <span style="color: rgb(0, 0, 0);">{</span>
     <span style="color: rgb(6, 0, 255);">def</span> f <span style="color: rgb(0, 0, 0);">(</span>y&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span> <span style="color: rgb(0, 0, 0);">{</span> x + y <span style="color: rgb(0, 0, 0);">}</span>;
     <span style="color: rgb(0, 0, 0);">System</span>.Console.WriteLine <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"{0}"</span>, run_twice <span style="color: rgb(0, 0, 0);">(</span>f, <span style="color: rgb(255, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
   <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
   <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">static</span> Run <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
   <span style="color: rgb(0, 0, 0);">{</span>
     run_adder <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">)</span>;
     run_adder <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">2</span><span style="color: rgb(0, 0, 0);">)</span>;
   <span style="color: rgb(0, 0, 0);">}</span>
 <span style="color: rgb(0, 0, 0);">}</span></pre>
<p>This example prints <tt>3</tt> and <tt>5</tt>. Note how x is captured
in the local function <tt>f</tt>.
</p><p>Types of functions taking more than one argument are represented as
tuples. For example, the following function:
</p>
<pre class="nemerle"> some_function <span style="color: rgb(0, 0, 0);">(</span>_arg1&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>, _arg2&nbsp;: <span style="color: rgb(255, 0, 0);">string</span>, _arg3&nbsp;: SomeFoo<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">float</span>
 <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(0, 128, 128); font-style: italic;">//  ...</span>
    <span style="color: rgb(0, 0, 0);">System</span>.Convert.ToSingle <span style="color: rgb(0, 0, 0);">(</span>_arg1<span style="color: rgb(0, 0, 0);">)</span>
 <span style="color: rgb(0, 0, 0);">}</span></pre>
<p>has the type <tt>int * string * Foo -&gt; float</tt>. Functions that take
no arguments pretend to take one argument of the type <tt>void</tt>. Thus the
function:
</p>
<pre class="nemerle"> other_function <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">string</span> <span style="color: rgb(0, 0, 0);">{</span> <span style="color: rgb(128, 128, 128);">"kaboo"</span> <span style="color: rgb(0, 0, 0);">}</span></pre>
<p>possesses the type <tt>void -&gt; string</tt>.
</p>
<a name="Lambda_expressions"></a><h2> Lambda expressions </h2>
<p>Lambda expressions are just a syntactic sugar to defined unnamed local
functions. Unnamed local functions are useful when you need to pass some
function to the iterator, so you use it just once.
</p><p>Lambda expressions are defined using the fun keyword, followed by formal
parameters, an optional return type and the function body.
</p>
<pre class="nemerle">&nbsp;
 <span style="color: rgb(6, 0, 255);">def</span> x = <span style="color: rgb(0, 0, 0);">Nemerle</span>.Collections.List.Map <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">1</span>, <span style="color: rgb(255, 0, 0);">2</span>, <span style="color: rgb(255, 0, 0);">3</span><span style="color: rgb(0, 0, 0);">]</span>, <span style="color: rgb(6, 0, 255);">fun</span> <span style="color: rgb(0, 0, 0);">(</span>x<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span> <span style="color: rgb(255, 0, 0);">2</span> * x <span style="color: rgb(0, 0, 0);">}</span><span style="color: rgb(0, 0, 0);">)</span>;
 <span style="color: rgb(6, 0, 255);">def</span> y = <span style="color: rgb(0, 0, 0);">Nemerle</span>.Collections.List.FoldLeft <span style="color: rgb(0, 0, 0);">(</span>x, <span style="color: rgb(255, 0, 0);">0</span>, <span style="color: rgb(6, 0, 255);">fun</span> <span style="color: rgb(0, 0, 0);">(</span>val&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>, acc<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span> acc + val <span style="color: rgb(0, 0, 0);">}</span><span style="color: rgb(0, 0, 0);">)</span>;
 assert <span style="color: rgb(0, 0, 0);">(</span>y == <span style="color: rgb(255, 0, 0);">12</span><span style="color: rgb(0, 0, 0);">)</span>;</pre>
<p>In general:
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">fun</span> <span style="color: rgb(0, 0, 0);">(</span>parms<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span> exprs <span style="color: rgb(0, 0, 0);">}</span></pre>
<p>is equivalent to:
</p>
<pre class="nemerle"><span style="color: rgb(0, 0, 0);">{</span> 
  <span style="color: rgb(6, 0, 255);">def</span> tmp <span style="color: rgb(0, 0, 0);">(</span>parms<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span> exprs <span style="color: rgb(0, 0, 0);">}</span>;
  tmp
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>This feature is similar to anonymous delegates in C# 2.0.
</p>
<a name="Exercises"></a><h2> Exercises </h2>
<p><b>2.1</b>. Write a function
</p>
<pre class="nemerle">string_pow&nbsp;: <span style="color: rgb(255, 0, 0);">int</span> * <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">string</span> -&gt; <span style="color: rgb(255, 0, 0);">string</span><span style="color: rgb(0, 0, 0);">)</span> * <span style="color: rgb(255, 0, 0);">string</span> -&gt; <span style="color: rgb(255, 0, 0);">string</span>;</pre>
<p>The call <tt>string_pow (3, f, "foo")</tt> should result in
calling <tt>f</tt> three times, i.e. returning result of <tt>f (f
(f ("foo")))</tt>. When you are done, write a second version of
<tt>string_pow</tt> using recursion (if you used imperative loop) or
imperative loop (otherwise).
</p><p>Test it by passing function that replaces "42" with "42ans". You can try
passing the functional argument to string_pow as a lambda expression.  <a href="http://msdn.microsoft.com/library/en-us/cpref/html/frlrfSystemStringClassReplaceTopic.asp" class="external text" title="http://msdn.microsoft.com/library/en-us/cpref/html/frlrfSystemStringClassReplaceTopic.asp">This method</a> might be useful.
</p>
<!-- Saved in parser cache with key wiki:pcache:idhash:972-0!1!0!0!!en!2 and timestamp 20060121193029 -->
<a name="chunk-Grok_Various_data_structures"></a>
	  	  <h1 class="firstHeading">Grok Various data structures</h1>
	    	    	    <!-- start content -->
	    <p>This page is a part of the <a href="#chunk-Grokking_Nemerle" title="Grokking Nemerle">Grokking Nemerle</a> tutorial.
</p>
<a name="Tuples"></a><h2> Tuples </h2>
<p>Tuples are forms of nameless data structures. They are usable when you
need to return two or three values from a function.
</p><p>A tuple is constructed with:
</p>
<pre class="nemerle"><span style="color: rgb(0, 0, 0);">(</span>expr1, expr2, ..., exprN<span style="color: rgb(0, 0, 0);">)</span></pre>
<p>and deconstructed with:
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">def</span> <span style="color: rgb(0, 0, 0);">(</span>id1, id2, ..., idN<span style="color: rgb(0, 0, 0);">)</span> = expr;</pre>
<p>This def thing defines values called <tt>id1</tt> through <tt>idN</tt>
and puts respective tuple members into them.
</p><p>Tuple types are written using the <tt>*</tt> operator. For example, pair
of integers <tt>(42, 314)</tt> has the type <tt>int * int</tt>, while
<tt>("Zephod", 42.0, 42)</tt> has the type <tt>string * float * int</tt>.
</p><p>An example follows:
</p>
<pre class="nemerle"><span style="color: rgb(0, 128, 128); font-style: italic;">/** Parses time in HH:MM format. */</span>
parse_time <span style="color: rgb(0, 0, 0);">(</span>time&nbsp;: <span style="color: rgb(255, 0, 0);">string</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span> * <span style="color: rgb(255, 0, 0);">int</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">def</span> arr = time.Split <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(6, 0, 255);">array</span> <span style="color: rgb(0, 0, 0);">[</span>':'<span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">System</span>.Int32.Parse <span style="color: rgb(0, 0, 0);">(</span>arr<span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">0</span><span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span>, <span style="color: rgb(0, 0, 0);">System</span>.Int32.Parse <span style="color: rgb(0, 0, 0);">(</span>arr<span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
seconds_since_midnight <span style="color: rgb(0, 0, 0);">(</span>time&nbsp;: <span style="color: rgb(255, 0, 0);">string</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">def</span> <span style="color: rgb(0, 0, 0);">(</span>hours, minutes<span style="color: rgb(0, 0, 0);">)</span> = parse_time <span style="color: rgb(0, 0, 0);">(</span>time<span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(0, 0, 0);">(</span>hours * <span style="color: rgb(255, 0, 0);">60</span> + minutes<span style="color: rgb(0, 0, 0);">)</span> * <span style="color: rgb(255, 0, 0);">60</span>
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
foo <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">def</span> secs = seconds_since_midnight <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"17:42"</span><span style="color: rgb(0, 0, 0);">)</span>;
  ...
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>Another example could be:
</p>
<pre class="nemerle"><span style="color: rgb(0, 128, 128); font-style: italic;">// split (3.7) =&gt; (3, 0.7)</span>
split <span style="color: rgb(0, 0, 0);">(</span>x&nbsp;: <span style="color: rgb(255, 0, 0);">double</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span> * <span style="color: rgb(255, 0, 0);">double</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">def</span> floor = <span style="color: rgb(0, 0, 0);">System</span>.Math.Floor <span style="color: rgb(0, 0, 0);">(</span>x<span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">System</span>.Convert.ToInt32 <span style="color: rgb(0, 0, 0);">(</span>floor<span style="color: rgb(0, 0, 0);">)</span>, x - floor<span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<a name="List_literals"></a><h2> List literals </h2>
<p>List literals are special forms of writing lists. Lists are data
structures that are used very often in Nemerle - often enough to get
their own syntax. Lists in Nemerle are somewhat different than the
<tt>ArrayList</tt> type in .NET.
</p>
<ul><li> the lists in Nemerle are immutable (cannot be changed once created)
</li><li> items can be appended at the beginning only (constructing new lists) 
</li></ul>
<p>Of course you are free to use the .NET <tt>ArrayList</tt>.
</p><p>Anyway, to construct a list consisting of a given <tt>head</tt> (first
element) and a <tt>tail</tt> (rest of elements, also a list), write:
</p>
<pre class="nemerle">head&nbsp;:: tail</pre>
<p>To construct a list with specified elements write:
</p>
<pre class="nemerle"><span style="color: rgb(0, 0, 0);">[</span> element_<span style="color: rgb(255, 0, 0);">1</span>, element_<span style="color: rgb(255, 0, 0);">2</span>, ..., element_n <span style="color: rgb(0, 0, 0);">]</span></pre>
<p>This way you can also construct an empty list (<tt>[]</tt>).
</p>
<!-- Saved in parser cache with key wiki:pcache:idhash:973-0!1!0!0!!en!2 and timestamp 20060121123042 -->
<a name="chunk-Grok_Variants_and_matching"></a>
	  	  <h1 class="firstHeading">Grok Variants and matching</h1>
	    	    	    <!-- start content -->
	    <p>This page is a part of the <a href="#chunk-Grokking_Nemerle" title="Grokking Nemerle">Grokking Nemerle</a> tutorial.
</p><p>Variants (called data types or sum types in <a href="http://www.smlnj.org/" class="external text" title="http://www.smlnj.org">SML</a> and <a href="http://www.ocaml.org/" class="external text" title="http://www.ocaml.org/">OCaml</a>) are forms of
expressing data of several different kinds.
</p><p>Matching is a way of destructuring complex data structures, especially
variants.
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Variants"><span class="tocnumber">1</span> <span class="toctext">Variants</span></a></li>
<li class="toclevel-1"><a href="#Matching"><span class="tocnumber">2</span> <span class="toctext">Matching</span></a></li>
<li class="toclevel-1"><a href="#Other_patterns"><span class="tocnumber">3</span> <span class="toctext">Other patterns</span></a></li>
<li class="toclevel-1"><a href="#Using_variants_as_trees"><span class="tocnumber">4</span> <span class="toctext">Using variants as trees</span></a></li>
<li class="toclevel-1"><a href="#XML_trees"><span class="tocnumber">5</span> <span class="toctext">XML trees</span></a></li>
<li class="toclevel-1"><a href="#Exercises"><span class="tocnumber">6</span> <span class="toctext">Exercises</span></a></li>
</ul>
</td></tr></tbody></table>
<p><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
</p>
<a name="Variants"></a><h2> Variants </h2>
<p>The simplest example of variants are enum types known from C.
</p>
<pre class="c"><span style="color: rgb(128, 128, 128); font-style: italic;">// C</span>
<span style="color: rgb(0, 0, 0); font-weight: bold;">enum</span> Color <span style="color: rgb(102, 204, 102);">{</span>
  Red, 
  Yellow, 
  Green 
<span style="color: rgb(102, 204, 102);">}</span></pre>
<pre class="nemerle"><span style="color: rgb(0, 128, 128); font-style: italic;">//  Nemerle</span>
<span style="color: rgb(6, 0, 255);">variant</span> Color <span style="color: rgb(0, 0, 0);">{</span>
   | Red
   | Yellow
   | Green
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>Note that you can define C#-like <tt>enum</tt> types in Nemerle anyway. 
</p>
<pre class="nemerle"><span style="color: rgb(0, 128, 128); font-style: italic;">//  Nemerle</span>
<span style="color: rgb(255, 0, 0);">enum</span> Color <span style="color: rgb(0, 0, 0);">{</span>
   | Red
   | Yellow
   | Green
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>However,
the variant options might be more useful because they can carry some
extra data with them:
</p>
<pre class="nemerle"> <span style="color: rgb(6, 0, 255);">variant</span> RgbColor <span style="color: rgb(0, 0, 0);">{</span>
   | Red
   | Yellow
   | Green
   | Different <span style="color: rgb(0, 0, 0);">{</span>
       red&nbsp;: <span style="color: rgb(255, 0, 0);">float</span>;
       green&nbsp;: <span style="color: rgb(255, 0, 0);">float</span>;
       blue&nbsp;: <span style="color: rgb(255, 0, 0);">float</span>;
     <span style="color: rgb(0, 0, 0);">}</span>
 <span style="color: rgb(0, 0, 0);">}</span></pre>
<p>So if color is neither red, yellow nor green, it can be represented
with RGB. You can create variant object just like any other object,
by using its constructor (which is always implicitly provided):
</p>
<pre class="nemerle">     <span style="color: rgb(0, 128, 128); font-style: italic;">//  ...</span>
     <span style="color: rgb(6, 0, 255);">def</span> _blue = RgbColor.Different <span style="color: rgb(0, 0, 0);">(</span>0f, 0f, 1f<span style="color: rgb(0, 0, 0);">)</span>;
     <span style="color: rgb(6, 0, 255);">def</span> _red = RgbColor.Red <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;</pre>
<p>You can think about variants as of a union with a selector in C. In OO
world sometimes modeling variants with sub classing can be seen sometimes:
</p>
<pre class="csharp"><span style="color: rgb(0, 128, 128); font-style: italic;">// C#</span>
<span style="color: rgb(255, 0, 0);">class</span> Color <span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(255, 0, 0);">class</span> Red&nbsp;: Color <span style="color: rgb(0, 0, 0);">{</span> <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(255, 0, 0);">class</span> Green&nbsp;: Color <span style="color: rgb(0, 0, 0);">{</span> <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(255, 0, 0);">class</span> Yellow&nbsp;: Color <span style="color: rgb(0, 0, 0);">{</span> <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(255, 0, 0);">class</span> Different&nbsp;: Color <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(255, 0, 0);">float</span> red;
    <span style="color: rgb(255, 0, 0);">float</span> green;
    <span style="color: rgb(255, 0, 0);">float</span> blue;
  
    <span style="color: rgb(6, 0, 255);">public</span> Different <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">float</span> red, <span style="color: rgb(255, 0, 0);">float</span> green, <span style="color: rgb(255, 0, 0);">float</span> blue<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
      <span style="color: rgb(6, 0, 255);">this</span>.<span style="color: rgb(0, 0, 255);">red</span> = red;
      <span style="color: rgb(6, 0, 255);">this</span>.<span style="color: rgb(0, 0, 255);">green</span> = green;
      <span style="color: rgb(6, 0, 255);">this</span>.<span style="color: rgb(0, 0, 255);">blue</span> = blue;
    <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>Of course you need to write a constructor, mark fields public and so
on. When you're done -- using this kind of stuff is quite hard -- you
need to use lots of runtime type checks.
</p><p>On the other hand, Nemerle provides an easy and convenient method of
dealing with variants -- pattern matching.
</p>
<a name="Matching"></a><h2> Matching </h2>
<p><b>Pattern matching</b> is accomplished with the match expression. Its
semantics are to check each pattern in turn, from top to bottom, and
execute expression after the first pattern that matched. If no pattern
matched, the exception is raised. This is like the switch statement
known from C, but using a large dose of steroids.
</p>
<pre class="nemerle">string_of_color <span style="color: rgb(0, 0, 0);">(</span>color&nbsp;: Color<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">string</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">match</span> <span style="color: rgb(0, 0, 0);">(</span>color<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
    | Color.Red =&gt; <span style="color: rgb(128, 128, 128);">"red"</span>
    | Color.Yellow =&gt; <span style="color: rgb(128, 128, 128);">"yellow"</span>
    | Color.Green =&gt; <span style="color: rgb(128, 128, 128);">"green"</span>
    | Color.Different <span style="color: rgb(0, 0, 0);">(</span>r, g, b<span style="color: rgb(0, 0, 0);">)</span> =&gt; 
      <span style="color: rgb(0, 0, 0);">System</span>.<span style="color: rgb(255, 0, 0);">String</span>.Format <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"rgb({0},{1},{2})"</span>, r, g, b<span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>The main idea behind patterns is that they match values that look like
them. For example, the Nemerle compiler creates a default constructor
for the <tt>Different</tt> variant option with the following body:
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">this</span> <span style="color: rgb(0, 0, 0);">(</span>red&nbsp;: <span style="color: rgb(255, 0, 0);">float</span>, green&nbsp;: <span style="color: rgb(255, 0, 0);">float</span>, blue&nbsp;: <span style="color: rgb(255, 0, 0);">float</span><span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">this</span>.red = red;
  <span style="color: rgb(6, 0, 255);">this</span>.green = green;
  <span style="color: rgb(6, 0, 255);">this</span>.blue = blue;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>Therefore, the constructor call <tt>Color.Different (r, g, b)</tt>
creates a new variant option instance with specified arguments. The
pattern looks the same -- it binds actual values of <tt>red</tt>,
<tt>green</tt> and <tt>blue</tt> fields to <tt>r</tt>, <tt>g</tt> and
<tt>b</tt> respectively. You can also spell the field names explicitly:
</p>
<pre class="nemerle">  | Color.Different <span style="color: rgb(0, 0, 0);">(</span>red = r, green = g, blue = b<span style="color: rgb(0, 0, 0);">)</span> =&gt; 
    <span style="color: rgb(0, 0, 0);">System</span>.<span style="color: rgb(255, 0, 0);">String</span>.Format <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"rgb({0},{1},{2})"</span>, r, g, b<span style="color: rgb(0, 0, 0);">)</span></pre>
<a name="Other_patterns"></a><h2> Other patterns </h2>
<p>We have already seen a so called <b>"constructor pattern"</b> in action. It
is used to match over variants. The constructor pattern consists of
variant option name (starting with an uppercase letter) followed by
optional tuple or record pattern.
</p>
<pre class="nemerle"><span style="color: rgb(0, 128, 128); font-style: italic;">// examples of constructor patterns</span>
<span style="color: rgb(0, 128, 128); font-style: italic;">// plain one, without sub-pattern:</span>
Color.Red 
<span style="color: rgb(0, 128, 128); font-style: italic;">// followed by tuple pattern:</span>
Color.Different <span style="color: rgb(0, 0, 0);">(</span>r, g, b<span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 128, 128); font-style: italic;">// followed by record pattern:</span>
Color.Different <span style="color: rgb(0, 0, 0);">(</span>red = r, green = g, blue = b<span style="color: rgb(0, 0, 0);">)</span></pre>
<p>The <b>variable pattern</b> matches any value, and binds it to a specified
variable. The variable pattern is an identifier starting with a lowercase
letter. They are used mostly inside other patterns, but here we give a
(rather pointless) example of using them as the top-level pattern:
</p>
<pre class="nemerle"><span style="color: rgb(0, 128, 128); font-style: italic;">// it prints 42</span>
<span style="color: rgb(6, 0, 255);">match</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">42</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
  | x =&gt; <span style="color: rgb(0, 128, 128); font-style: italic;">// here x is bound to 42</span>
    printf <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"%d<span style="color: rgb(0, 128, 128); font-weight: bold;">\n</span>"</span>, x<span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>The <b>throw-away pattern</b>, written _, matches any value and has no
further effects. It is a way of specifying the default: case in matching.
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">match</span> <span style="color: rgb(0, 0, 0);">(</span>color<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
  | Color.Red =&gt; <span style="color: rgb(128, 128, 128);">"red"</span>
  | _ =&gt; <span style="color: rgb(128, 128, 128);">"other"</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>The <b>tuple pattern</b> consists of one or more patterns separated by commas
and surrounded by parens. We have already used them in the <a href="#chunk-Grok_Various_data_structures" title="Grok Various data structures">section about tuples</a> above. There they were used in 
<tt>def</tt> expressions.
</p>
<pre class="nemerle"><span style="color: rgb(0, 128, 128); font-style: italic;">// matches any pair, binding its elements</span>
<span style="color: rgb(0, 128, 128); font-style: italic;">// to specified variables</span>
<span style="color: rgb(0, 0, 0);">(</span>first_element, second_element<span style="color: rgb(0, 0, 0);">)</span>
&nbsp;
<span style="color: rgb(0, 128, 128); font-style: italic;">// matches a pair whose first element is Foo</span>
<span style="color: rgb(0, 0, 0);">(</span>Foo, _<span style="color: rgb(0, 0, 0);">)</span></pre>
<p>The <b>record pattern</b> consists of class name and zero or more named
patterns separated by commas enclosed in parentheses. It matches a class,
whose field values are matched by sub-patterns.
</p>
<pre class="nemerle"><span style="color: rgb(255, 0, 0);">class</span> Foo <span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> number&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>;
  <span style="color: rgb(6, 0, 255);">public</span> name&nbsp;: <span style="color: rgb(255, 0, 0);">string</span>;
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
StringOfFoo <span style="color: rgb(0, 0, 0);">(</span>f&nbsp;: Foo<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">string</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>f.name == <span style="color: rgb(128, 128, 128);">""</span><span style="color: rgb(0, 0, 0);">)</span>
    f.number.ToString <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(6, 0, 255);">else</span>
    f.name
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
<span style="color: rgb(0, 128, 128); font-style: italic;">// do the same as above</span>
StringOfFooMatch <span style="color: rgb(0, 0, 0);">(</span>f&nbsp;: Foo<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">string</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">match</span> <span style="color: rgb(0, 0, 0);">(</span>f<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
    | Foo <span style="color: rgb(6, 0, 255);">where</span> <span style="color: rgb(0, 0, 0);">(</span>name = <span style="color: rgb(128, 128, 128);">""</span>, number = k<span style="color: rgb(0, 0, 0);">)</span> =&gt;
      k.ToString <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
    | Foo <span style="color: rgb(6, 0, 255);">where</span> <span style="color: rgb(0, 0, 0);">(</span>name = s<span style="color: rgb(0, 0, 0);">)</span> =&gt; 
      s
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>It might be doubtful if <tt>string_of_foo_match</tt> is any better than
<tt>string_of_foo</tt>. Record patterns are mostly useful when used
inside a complex pattern, or when they contain complex patterns.
</p><p>The <b>literal pattern</b> is an integer, character or string constant. It
matches the exact specified value.
</p>
<pre class="nemerle">StringOfInt <span style="color: rgb(0, 0, 0);">(</span>n&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">string</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">match</span> <span style="color: rgb(0, 0, 0);">(</span>n<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
    | <span style="color: rgb(255, 0, 0);">0</span> =&gt; <span style="color: rgb(128, 128, 128);">"null"</span>
    | <span style="color: rgb(255, 0, 0);">1</span> =&gt; <span style="color: rgb(128, 128, 128);">"one"</span>
    | <span style="color: rgb(255, 0, 0);">2</span> =&gt; <span style="color: rgb(128, 128, 128);">"two"</span>
    | <span style="color: rgb(255, 0, 0);">3</span> =&gt; <span style="color: rgb(128, 128, 128);">"three"</span>
    | _ =&gt; <span style="color: rgb(128, 128, 128);">"more"</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
IntOfString <span style="color: rgb(0, 0, 0);">(</span>n&nbsp;: <span style="color: rgb(255, 0, 0);">string</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>
<span style="color: rgb(0, 0, 0);">{</span>
  | <span style="color: rgb(128, 128, 128);">"null"</span> =&gt; <span style="color: rgb(255, 0, 0);">0</span>
  | <span style="color: rgb(128, 128, 128);">"one"</span> =&gt; <span style="color: rgb(255, 0, 0);">1</span>
  | <span style="color: rgb(128, 128, 128);">"two"</span> =&gt; <span style="color: rgb(255, 0, 0);">2</span>
  | <span style="color: rgb(128, 128, 128);">"three"</span> =&gt; <span style="color: rgb(255, 0, 0);">3</span>
  | _ =&gt; <span style="color: rgb(255, 0, 0);">42</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>Note lack of <tt>match</tt> in the second example. When the function
body starts with <tt>|</tt> -- the <tt>match</tt> expression is
automagically inserted.
</p><p>The <b>as pattern</b> tries to match a value with a pattern enclosed within
it, and in case of success binds the value that matched to a specified
variable. We will show it later.
</p><p>There are also two patterns related to types. The first one is the <b>type</b>
enforcement pattern<b>. Its job is to give a hint to type inference</b>
engine. It consists of a pattern followed by a colon and a type, like:
<tt>x&nbsp;: Foo</tt> or <tt>(x,y)&nbsp;: Foo * Bar</tt>. It requires type of the
matched value to be statically known to subtype the type specified.
</p><p>The other pattern related to type is the <b>type check pattern</b>. Is
is used to check whether the value matched has the specified type. It
consists of a variable followed by the keyword is and a type. If the
runtime type of the value matched is subtype of the type specified,
the branch is taken and the matched value is bound to specified variable.
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">match</span> <span style="color: rgb(0, 0, 0);">(</span>some_value<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
  | x <span style="color: rgb(0, 128, 0);">is</span> SomeType =&gt;
    <span style="color: rgb(0, 128, 128); font-style: italic;">// use x</span>
  | x <span style="color: rgb(0, 128, 0);">is</span> SomeOtherType =&gt;
    <span style="color: rgb(0, 128, 128); font-style: italic;">// use x</span>
  | _ =&gt; ...
<span style="color: rgb(0, 0, 0);">}</span></pre>
<a name="Using_variants_as_trees"></a><h2> Using variants as trees </h2>
<p>The example above, while simple, is not the best usage of
variants. Variants are best at handling tree-like data structures. A
common example of tree data structures are XML documents. However,
we will deal with plain binary trees first.
</p><p>The following example defines the type of trees of integers (representing
sets).
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">variant</span> Tree <span style="color: rgb(0, 0, 0);">{</span>
  | Node <span style="color: rgb(0, 0, 0);">{</span>
      left &nbsp;: Tree;
      elem &nbsp;: <span style="color: rgb(255, 0, 0);">int</span>;
      right&nbsp;: Tree;
    <span style="color: rgb(0, 0, 0);">}</span>
  | <span style="color: rgb(6, 0, 255);">Null</span>
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
<span style="color: rgb(0, 128, 128); font-style: italic;">// return tree t with element e inserted</span>
Insert <span style="color: rgb(0, 0, 0);">(</span>t&nbsp;: Tree, e&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: Tree
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">match</span> <span style="color: rgb(0, 0, 0);">(</span>t<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
    | Tree.Node <span style="color: rgb(0, 0, 0);">(</span>l, cur, r<span style="color: rgb(0, 0, 0);">)</span> =&gt;
      <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>e &lt; cur<span style="color: rgb(0, 0, 0);">)</span>
        Tree.Node <span style="color: rgb(0, 0, 0);">(</span>insert <span style="color: rgb(0, 0, 0);">(</span>l, e<span style="color: rgb(0, 0, 0);">)</span>, cur, r<span style="color: rgb(0, 0, 0);">)</span>
      <span style="color: rgb(6, 0, 255);">else</span> <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>e &gt; cur<span style="color: rgb(0, 0, 0);">)</span>
        Tree.Node <span style="color: rgb(0, 0, 0);">(</span>l, cur, insert <span style="color: rgb(0, 0, 0);">(</span>r, e<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
      <span style="color: rgb(6, 0, 255);">else</span>
        <span style="color: rgb(0, 128, 128); font-style: italic;">// node already in the tree,</span>
        <span style="color: rgb(0, 128, 128); font-style: italic;">// return the same tree</span>
        t
    | Tree.<span style="color: rgb(6, 0, 255);">Null</span> =&gt;
      Tree.Node <span style="color: rgb(0, 0, 0);">(</span>Tree.<span style="color: rgb(6, 0, 255);">Null</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>, e, Tree.<span style="color: rgb(6, 0, 255);">Null</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
<span style="color: rgb(0, 128, 128); font-style: italic;">// check if specified integer is in the tree</span>
Contains <span style="color: rgb(0, 0, 0);">(</span>t&nbsp;: Tree, e&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">bool</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">match</span> <span style="color: rgb(0, 0, 0);">(</span>t<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
    | Tree.Node <span style="color: rgb(0, 0, 0);">(</span>l, cur, r<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(6, 0, 255);">when</span> e &lt; cur =&gt; 
      Contains <span style="color: rgb(0, 0, 0);">(</span>l, e<span style="color: rgb(0, 0, 0);">)</span>
&nbsp;
    | Tree.Node <span style="color: rgb(0, 0, 0);">(</span>l, cur, r<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(6, 0, 255);">when</span> e &gt; cur =&gt; 
      Contains <span style="color: rgb(0, 0, 0);">(</span>r, e<span style="color: rgb(0, 0, 0);">)</span>
&nbsp;
    | Tree.Node =&gt; <span style="color: rgb(6, 0, 255);">true</span>
    | Tree.<span style="color: rgb(6, 0, 255);">Null</span> =&gt; <span style="color: rgb(6, 0, 255);">false</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<a name="XML_trees"></a><h2> XML trees </h2>
<p>As you can see binary trees are not very interesting, so we will go to
XML. Whether XML is interesting remains a doubtful question, but at least it is
somewhat more practical.
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">variant</span> Node <span style="color: rgb(0, 0, 0);">{</span>
  | Text <span style="color: rgb(0, 0, 0);">{</span> 
      value&nbsp;: <span style="color: rgb(255, 0, 0);">string</span>; 
    <span style="color: rgb(0, 0, 0);">}</span>
  | Element <span style="color: rgb(0, 0, 0);">{</span>
      name&nbsp;: <span style="color: rgb(255, 0, 0);">string</span>; 
      children&nbsp;: list <span style="color: rgb(0, 0, 0);">[</span>Node<span style="color: rgb(0, 0, 0);">]</span>;
    <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>This variant defines a simplistic data structure to hold XML trees. An XML
node is either a text node with a specified text inside, or an element
node, with a name and zero or more children. A sequence of children
is represented as a Nemerle list data structure (Nemerle has even
a <a href="#chunk-Grok_Various_data_structures" title="Grok Various data structures">special syntax for lists</a>). The type is
written here <tt>list [Node]</tt> -- a list of nodes. We will learn more about
polymorphic variants later.
</p><p>For example the following tree:
</p>
<pre class="xml"><span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;tree<span style="font-weight: bold; color: black;">&gt;</span></span></span>
  <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;branch<span style="font-weight: bold; color: black;">&gt;</span></span></span>
    <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;leaf</span><span style="font-weight: bold; color: black;">/&gt;</span></span>
  <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;/branch<span style="font-weight: bold; color: black;">&gt;</span></span></span>
  <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;branch<span style="font-weight: bold; color: black;">&gt;</span></span></span>
    Foo
  <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;/branch<span style="font-weight: bold; color: black;">&gt;</span></span></span>
<span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;/tree<span style="font-weight: bold; color: black;">&gt;</span></span></span></pre>
<p>would be represented by:
</p>
<pre class="nemerle">Node.Element <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"tree"</span>, 
  <span style="color: rgb(0, 0, 0);">[</span>Node.Element <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"branch"</span>, <span style="color: rgb(0, 0, 0);">[</span>Node.Element <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"leaf"</span>, <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span>,
   Node.Element <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"branch"</span>, <span style="color: rgb(0, 0, 0);">[</span>Node.Text <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"Foo"</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span></pre>
<p>Of course XML by itself is just a data format. Using data in the
above form wouldn't be too easy. So we want some different internal
representation of data, and use XML only to save it or send it over
the network.
</p>
<pre class="nemerle"><span style="color: rgb(255, 0, 0);">class</span> Refrigerator
<span style="color: rgb(0, 0, 0);">{</span>
  minimal_temperature&nbsp;: <span style="color: rgb(255, 0, 0);">float</span>;
  content&nbsp;: list <span style="color: rgb(0, 0, 0);">[</span>RefrigeratorContent<span style="color: rgb(0, 0, 0);">]</span>;
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
<span style="color: rgb(6, 0, 255);">variant</span> RefrigeratorContent
<span style="color: rgb(0, 0, 0);">{</span>
  | Beer <span style="color: rgb(0, 0, 0);">{</span> name&nbsp;: <span style="color: rgb(255, 0, 0);">string</span>; volume&nbsp;: <span style="color: rgb(255, 0, 0);">float</span>; <span style="color: rgb(0, 0, 0);">}</span>
  | Chips <span style="color: rgb(0, 0, 0);">{</span> weight&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>; <span style="color: rgb(0, 0, 0);">}</span>
  | Ketchup
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>Now we'll write simple XML parsing function.
</p>
<pre class="nemerle">ParseRefrigerator <span style="color: rgb(0, 0, 0);">(</span>n&nbsp;: Node<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: Refrigerator
<span style="color: rgb(0, 0, 0);">{</span>
  | Node.Element <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"refrigerator"</span>, 
      Node.Element <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"minimal-temperature"</span>, <span style="color: rgb(0, 0, 0);">[</span>Node.Text <span style="color: rgb(0, 0, 0);">(</span>min_temp<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span> 
           &nbsp;:: content<span style="color: rgb(0, 0, 0);">)</span> =&gt;
        Refrigerator <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">System</span>.<span style="color: rgb(255, 0, 0);">Float</span>.Parse <span style="color: rgb(0, 0, 0);">(</span>min_temp<span style="color: rgb(0, 0, 0);">)</span>, 
                      ParseRefrigeratorContent <span style="color: rgb(0, 0, 0);">(</span>content<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
  | _ =&gt;
    <span style="color: rgb(6, 0, 255);">throw</span> <span style="color: rgb(0, 0, 0);">System</span>.ArgumentException <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
ParseRefrigeratorContent <span style="color: rgb(0, 0, 0);">(</span>nodes&nbsp;: list <span style="color: rgb(0, 0, 0);">[</span>Node<span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span> 
 &nbsp;: list <span style="color: rgb(0, 0, 0);">[</span>RefrigeratorContent<span style="color: rgb(0, 0, 0);">]</span>
<span style="color: rgb(0, 0, 0);">{</span>
  | <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(0, 0, 0);">]</span> =&gt; <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(0, 0, 0);">]</span>
  
  | node&nbsp;:: rest =&gt;
    <span style="color: rgb(6, 0, 255);">def</span> food =
      <span style="color: rgb(6, 0, 255);">match</span> <span style="color: rgb(0, 0, 0);">(</span>node<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
        | Node.Element <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"ketchup"</span>, <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span> =&gt;
          RefrigeratorContent.Ketchup <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
          
        | Node.Element <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"beer"</span>, 
            <span style="color: rgb(0, 0, 0);">[</span>Node.Element <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"name"</span>, <span style="color: rgb(0, 0, 0);">[</span>Node.Text <span style="color: rgb(0, 0, 0);">(</span>name<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span>,
             Node.Element <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"volume"</span>, <span style="color: rgb(0, 0, 0);">[</span>Node.Text <span style="color: rgb(0, 0, 0);">(</span>volume<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span> =&gt;
          RefrigeratorContent.Beer <span style="color: rgb(0, 0, 0);">(</span>name, <span style="color: rgb(0, 0, 0);">System</span>.<span style="color: rgb(255, 0, 0);">Float</span>.Parse <span style="color: rgb(0, 0, 0);">(</span>volume<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
          
        | Node.Element <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"chips"</span>,
            <span style="color: rgb(0, 0, 0);">[</span>Node.Element <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"weight"</span>, <span style="color: rgb(0, 0, 0);">[</span>Node.Text <span style="color: rgb(0, 0, 0);">(</span>weight<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span> =&gt;
          RefrigeratorContent.Chips <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">System</span>.Int32.Parse <span style="color: rgb(0, 0, 0);">(</span>weight<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
          
        | _ =&gt;
          <span style="color: rgb(6, 0, 255);">throw</span> <span style="color: rgb(0, 0, 0);">System</span>.ArgumentException <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
      <span style="color: rgb(0, 0, 0);">}</span>;
    food&nbsp;:: ParseRefrigeratorContent <span style="color: rgb(0, 0, 0);">(</span>rest<span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>The reader will easily note that a) this code looks a bit like a junk,
b) it can be generated automatically and c) in C# it would be even
worse. Later we will learn how to write macros to generate this kind of
code automatically.
</p><p>But let's leave the ideology behind. There are probably few interesting
things about this example. The first is the usage of list patterns and
constructors. We can check if a list is empty, and if not, deconstruct
it with the following code:
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">match</span> <span style="color: rgb(0, 0, 0);">(</span>l<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
  | <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(0, 0, 0);">]</span> =&gt; 
    <span style="color: rgb(0, 128, 128); font-style: italic;">// the list is empty</span>
    <span style="color: rgb(0, 128, 128); font-style: italic;">// ...</span>
  | head&nbsp;:: rest =&gt;
    <span style="color: rgb(0, 128, 128); font-style: italic;">// the list isn't empty, the first element </span>
    <span style="color: rgb(0, 128, 128); font-style: italic;">// of the list is bound to the 'head' variable</span>
    <span style="color: rgb(0, 128, 128); font-style: italic;">// and the rest of the list to 'rest'</span>
    <span style="color: rgb(0, 128, 128); font-style: italic;">// ...</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>We can also construct new lists with <tt>::</tt> operator -- it prepends
an element to an existing list. If we know all list elements in advance
we can use the <tt>[ ... ]</tt> thing in both expressions and patterns.
</p><p>The second interesting thing is that we throw an exception in case of
problems. We will talk about it later, for now assume, it just terminates
the program with an error message.
</p>
<a name="Exercises"></a><h2> Exercises </h2>
<p><b>2.2</b> (2 points). Write a function that reads XML from specified
files and puts it into the <tt>Node</tt> variant defined above. Then write a
function to dump your data in a lispy format, something like:
</p>
<pre>(tree
(branch
(leaf)
)
(branch
($text "Foo")
)
)
</pre>
<p>For an extra point implement indentation of output.
</p>
<pre>(tree
  (branch
    (leaf))
  (branch
    ($text "Foo")))
</pre>
<p><br>
Then copy the Parser functions from above, fix any errors you find in
them and try to parse the following file:
</p>
<pre class="xml"><span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;</span>?xml <span style="color: rgb(0, 0, 102);">version</span>=<span style="color: rgb(255, 0, 0);">'1.0'</span> <span style="color: rgb(0, 0, 102);">encoding</span>=<span style="color: rgb(255, 0, 0);">'utf-8'</span>&nbsp;?<span style="font-weight: bold; color: black;">&gt;</span></span>
<span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;refrigerator<span style="font-weight: bold; color: black;">&gt;</span></span></span>
  <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;minimal</span>-temperature<span style="font-weight: bold; color: black;">&gt;</span></span>-3.0<span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;/minimal</span>-temperature<span style="font-weight: bold; color: black;">&gt;</span></span>
  <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;beer<span style="font-weight: bold; color: black;">&gt;</span></span></span>
    <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;name<span style="font-weight: bold; color: black;">&gt;</span></span></span>Hyneken<span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;/name<span style="font-weight: bold; color: black;">&gt;</span></span></span>
    <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;volume<span style="font-weight: bold; color: black;">&gt;</span></span></span>0.6<span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;/volume<span style="font-weight: bold; color: black;">&gt;</span></span></span>
  <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;/beer<span style="font-weight: bold; color: black;">&gt;</span></span></span>
  <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;beer<span style="font-weight: bold; color: black;">&gt;</span></span></span>
    <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;name<span style="font-weight: bold; color: black;">&gt;</span></span></span>Bydweisser<span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;/name<span style="font-weight: bold; color: black;">&gt;</span></span></span>
    <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;volume<span style="font-weight: bold; color: black;">&gt;</span></span></span>0.5<span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;/volume<span style="font-weight: bold; color: black;">&gt;</span></span></span>
  <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;/beer<span style="font-weight: bold; color: black;">&gt;</span></span></span>
  <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;beer<span style="font-weight: bold; color: black;">&gt;</span></span></span>
    <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;name<span style="font-weight: bold; color: black;">&gt;</span></span></span>Plsner<span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;/name<span style="font-weight: bold; color: black;">&gt;</span></span></span>
    <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;volume<span style="font-weight: bold; color: black;">&gt;</span></span></span>0.5<span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;/volume<span style="font-weight: bold; color: black;">&gt;</span></span></span>
  <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;/beer<span style="font-weight: bold; color: black;">&gt;</span></span></span>
  <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;chips<span style="font-weight: bold; color: black;">&gt;</span></span></span>
    <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;weight<span style="font-weight: bold; color: black;">&gt;</span></span></span>500<span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;/weight<span style="font-weight: bold; color: black;">&gt;</span></span></span>
  <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;/chips<span style="font-weight: bold; color: black;">&gt;</span></span></span>
  <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;ketchup</span><span style="font-weight: bold; color: black;">/&gt;</span></span>
<span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;/refrigerator<span style="font-weight: bold; color: black;">&gt;</span></span></span></pre>
<p>Warning: you do not need to write the XML parser. You should not do
it, actually. Use the <a href="http://msdn.microsoft.com/library/en-us/cpref/html/frlrfsystemxml.asp" class="external text" title="http://msdn.microsoft.com/library/en-us/cpref/html/frlrfsystemxml.asp">System.Xml</a> namespace from the .NET Framework. In
order to link with the System.Xml library you need to compile with the
<tt>-r:System.Xml</tt> option. For example:
</p>
<pre> ncc -r System.Xml myprogram.n
</pre>
<p>should do.
</p>
<!-- Saved in parser cache with key wiki:pcache:idhash:974-0!1!0!0!!en!2 and timestamp 20060120214105 -->
<a name="chunk-Grok_The_rest"></a>
	  	  <h1 class="firstHeading">Grok The rest</h1>
	    	    	    <!-- start content -->
	    <p>This page is a part of the <a href="#chunk-Grokking_Nemerle" title="Grokking Nemerle">Grokking Nemerle</a> tutorial.
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Named_parameters"><span class="tocnumber">1</span> <span class="toctext">Named parameters</span></a></li>
<li class="toclevel-1"><a href="#The_void_literal"><span class="tocnumber">2</span> <span class="toctext">The void literal</span></a></li>
<li class="toclevel-1"><a href="#Operator_overloading"><span class="tocnumber">3</span> <span class="toctext">Operator overloading</span></a></li>
<li class="toclevel-1"><a href="#Macros"><span class="tocnumber">4</span> <span class="toctext">Macros</span></a>
<ul>
<li class="toclevel-2"><a href="#Core_language_constructs"><span class="tocnumber">4.1</span> <span class="toctext">Core language constructs</span></a></li>
<li class="toclevel-2"><a href="#Design_by_contract"><span class="tocnumber">4.2</span> <span class="toctext">Design by contract</span></a></li>
<li class="toclevel-2"><a href="#Other_examples"><span class="tocnumber">4.3</span> <span class="toctext">Other examples</span></a></li>
</ul>
</li>
</ul>
</td></tr></tbody></table>
<p><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
</p>
<a name="Named_parameters"></a><h2> Named parameters </h2>
<p>This feature (in this form) comes from python. When you call a function
you can name some of its parameters (which allows putting them in a
different order than in the definition).
</p>
<pre class="nemerle">frobnicate <span style="color: rgb(0, 0, 0);">(</span>foo&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>, do_qux&nbsp;: <span style="color: rgb(255, 0, 0);">bool</span>, 
                       do_baz&nbsp;: <span style="color: rgb(255, 0, 0);">bool</span>, 
                       do_bar&nbsp;: <span style="color: rgb(255, 0, 0);">bool</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(0, 128, 128); font-style: italic;">// this is completely meaningless</span>
  <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>do_qux &amp;&amp;&nbsp;!do_baz<span style="color: rgb(0, 0, 0);">)</span> foo * <span style="color: rgb(255, 0, 0);">2</span>
  <span style="color: rgb(6, 0, 255);">else</span> <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>do_bar<span style="color: rgb(0, 0, 0);">)</span> foo * <span style="color: rgb(255, 0, 0);">7</span>
  <span style="color: rgb(6, 0, 255);">else</span> <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>do_baz<span style="color: rgb(0, 0, 0);">)</span> foo * <span style="color: rgb(255, 0, 0);">13</span>
  <span style="color: rgb(6, 0, 255);">else</span> <span style="color: rgb(255, 0, 0);">42</span>
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
Main <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(0, 128, 128); font-style: italic;">// Parameters' names can be omitted.</span>
  <span style="color: rgb(6, 0, 255);">def</span> res1 = frobnicate <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">7</span>, <span style="color: rgb(6, 0, 255);">true</span>, <span style="color: rgb(6, 0, 255);">false</span>, <span style="color: rgb(6, 0, 255);">true</span><span style="color: rgb(0, 0, 0);">)</span>;
  
  <span style="color: rgb(0, 128, 128); font-style: italic;">// This is the intended usage -- the first </span>
  <span style="color: rgb(0, 128, 128); font-style: italic;">// (main) parameter comes without a name</span>
  <span style="color: rgb(0, 128, 128); font-style: italic;">// and the following flags with names</span>
  <span style="color: rgb(6, 0, 255);">def</span> res2 = frobnicate <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">7</span>, do_qux = <span style="color: rgb(6, 0, 255);">true</span>,
                            do_baz = <span style="color: rgb(6, 0, 255);">false</span>, 
                            do_bar = <span style="color: rgb(6, 0, 255);">true</span><span style="color: rgb(0, 0, 0);">)</span>;
                            
  <span style="color: rgb(0, 128, 128); font-style: italic;">// You can however name every parameter:</span>
  <span style="color: rgb(6, 0, 255);">def</span> res3 = frobnicate <span style="color: rgb(0, 0, 0);">(</span>foo = <span style="color: rgb(255, 0, 0);">7</span>, do_qux = <span style="color: rgb(6, 0, 255);">true</span>, 
                         do_baz = <span style="color: rgb(6, 0, 255);">false</span>, do_bar = <span style="color: rgb(6, 0, 255);">true</span><span style="color: rgb(0, 0, 0);">)</span>;
                         
  <span style="color: rgb(0, 128, 128); font-style: italic;">// And permute them:</span>
  <span style="color: rgb(6, 0, 255);">def</span> res3 = frobnicate <span style="color: rgb(0, 0, 0);">(</span>do_qux = <span style="color: rgb(6, 0, 255);">true</span>, do_bar = <span style="color: rgb(6, 0, 255);">true</span>, 
                         do_baz = <span style="color: rgb(6, 0, 255);">false</span>, foo = <span style="color: rgb(255, 0, 0);">7</span><span style="color: rgb(0, 0, 0);">)</span>;
                         
  <span style="color: rgb(0, 128, 128); font-style: italic;">// You can also omit names for any number of leading </span>
  <span style="color: rgb(0, 128, 128); font-style: italic;">// parameters and permute the trailing ones.</span>
  <span style="color: rgb(6, 0, 255);">def</span> res2 = frobnicate <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">7</span>, <span style="color: rgb(6, 0, 255);">true</span>,
                            do_bar = <span style="color: rgb(6, 0, 255);">true</span>,
                            do_baz = <span style="color: rgb(6, 0, 255);">false</span><span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>The rules behind named parameters are simple:
</p>
<ul><li> named parameters must come after all unnamed (positional) parameters
</li><li> positional parameters are assigned first
</li><li> the remaining parameters are assigned based on their names 
</li></ul>
<p>Named parameters can be used only when names of parameters are known
(which basically mean they do not work in conjunction with functional
values).
</p>
<a name="The_void_literal"></a><h2> The void literal </h2>
<p>The void literal is written: ().
</p><p>The void literal is quite a tricky thing, since it represents the
only value of type <tt>void</tt>, which, judging from the name,
should be ergh... void. In fact, in some other functional languages
this type is called <tt>unit</tt>, but in Nemerle the name comes from
<tt>System.Void</tt> and the <tt>void</tt> type is an alias for it.
</p><p>In C# the <tt>void</tt> type is used as a return type of functions. It
does not make much sense to use it elsewhere. It could be needed, however,
if, for example, you want to use the <tt>Hashtable [a, b]</tt> type as
a set representation of strings. You can use <tt>Hashtable [string,
void]</tt> then. And this is the place to use the void value -- when
you call a set method, you need to pass something as a value to set --
and you pass the void value.
</p><p>You can also use the void value to return it from a function -- as you
remember, the return value of function is the last expression in its
body. However, in most cases the last expression will already have the
right <tt>void</tt> type.
</p>
<a name="Operator_overloading"></a><h2> Operator overloading </h2>
<p>You can overload existing operators or add new ones simply by specifying
them as a static method in some type. The name of method should be
some quoted (with <tt>@</tt>) operator. For example, the following
class definition:
</p>
<pre class="nemerle"> <span style="color: rgb(255, 0, 0);">class</span> Operand <span style="color: rgb(0, 0, 0);">{</span>
   <span style="color: rgb(6, 0, 255);">public</span> val&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>;
   <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">this</span> <span style="color: rgb(0, 0, 0);">(</span>v&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span> val = v <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
   <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">static</span> @&lt;-&lt; <span style="color: rgb(0, 0, 0);">(</span>x&nbsp;: Operand, y&nbsp;: Operand<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: Operand <span style="color: rgb(0, 0, 0);">{</span>
     Operand <span style="color: rgb(0, 0, 0);">(</span>x.val + y.val<span style="color: rgb(0, 0, 0);">)</span>;
   <span style="color: rgb(0, 0, 0);">}</span>
 <span style="color: rgb(0, 0, 0);">}</span></pre>
<p>contains the <tt>&lt;-&lt;</tt> binary operator processing <tt>Operand</tt>
objects. It can be used like:
</p>
<pre class="nemerle">&nbsp;
 <span style="color: rgb(6, 0, 255);">def</span> x = Operand <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">2</span><span style="color: rgb(0, 0, 0);">)</span>;
 <span style="color: rgb(6, 0, 255);">def</span> y = Operand <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">3</span><span style="color: rgb(0, 0, 0);">)</span>;
 <span style="color: rgb(6, 0, 255);">def</span> z = x &lt;-&lt; y;
 assert <span style="color: rgb(0, 0, 0);">(</span>z.val == <span style="color: rgb(255, 0, 0);">5</span><span style="color: rgb(0, 0, 0);">)</span>;</pre>
<p>Unary operators can be created by giving only one parameter to the method.
</p>
<a name="Macros"></a><h2> Macros </h2>
<p>Nemerle has very powerful code-generating macros. They are more akin
to Lisp macros than macros found in C preprocessor. We are not going
to explain here how to write macros (if you are curious, please see
<a href="http://wiki.nemerle.org/Macros" title="Macros">macros tutorial</a>), but will describe a few often used macros.
</p>
<a name="Core_language_constructs"></a><h3> Core language constructs </h3>
<p>First of all, <tt>if</tt>, <tt>while</tt>, <tt>for</tt>, <tt>foreach</tt>, 
<tt>when</tt>, <tt>using</tt>, <tt>lock</tt>, etc. are all macros.
</p><p>When you write code like:
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">using</span> <span style="color: rgb(0, 0, 0);">(</span>stream = <span style="color: rgb(0, 0, 0);">System</span>.IO.FileStream <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"file.txt"</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span> 
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">lock</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(6, 0, 255);">this</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
    ...
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>it first gets transformed into
</p>
<pre class="nemerle">&nbsp;
<span style="color: rgb(6, 0, 255);">def</span> stream = <span style="color: rgb(0, 0, 0);">System</span>.IO.FileStream <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"file.txt"</span>, <span style="color: rgb(0, 0, 0);">System</span>.IO.FileMode.Open<span style="color: rgb(0, 0, 0);">)</span>;
<span style="color: rgb(6, 0, 255);">try</span> <span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(0, 0, 0);">System</span>.Threading.Monitor.Enter <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(6, 0, 255);">this</span><span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(6, 0, 255);">try</span> <span style="color: rgb(0, 0, 0);">{</span>
    ...
  <span style="color: rgb(0, 0, 0);">}</span> <span style="color: rgb(6, 0, 255);">finally</span> <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(0, 0, 0);">System</span>.Threading.Monitor.Exit <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(6, 0, 255);">this</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span> <span style="color: rgb(6, 0, 255);">finally</span> <span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">def</span> disp = <span style="color: rgb(0, 0, 0);">(</span>stream&nbsp;: <span style="color: rgb(0, 0, 0);">System</span>.IDisposable<span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(6, 0, 255);">when</span> <span style="color: rgb(0, 0, 0);">(</span>disp&nbsp;!= <span style="color: rgb(6, 0, 255);">null</span><span style="color: rgb(0, 0, 0);">)</span>
    disp.Dispose <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>The transformation is done by macros, which also introduce <i>using</i> and <i>lock</i> syntax to the language.
</p><p>The greatest thing is that programmer is allowed to define his own macros, introducing his <a href="http://wiki.nemerle.org/Syntax_extensions" title="Syntax extensions">own syntax</a>.
</p>
<a name="Design_by_contract"></a><h3> Design by contract </h3>
<p><a href="http://wiki.nemerle.org/Design_by_contract_macros" title="Design by contract macros">Design by contract macros</a>
allows you to specify assertions about your program. In other languages
they are usually laying around in comments, while in Nemerle you can
explicitly decorate code. This way <i>contracts</i> are instantly checked during program execution.
</p>
<a name="Other_examples"></a><h3> Other examples </h3>
<p>Other examples of macros:
</p>
<ul><li> <tt>printf</tt>, <tt>sprintf</tt> -- uses a similar syntax to the same function in C, but is checked at the compile time
</li><li> <tt>scanf</tt> -- likewise
</li><li> <tt>print</tt> -- it does the $-expansion known from shell or perl
</li><li> <tt>assert</tt> -- much like the C macro
</li></ul>
<p>You can see a <a href="http://wiki.nemerle.org/MacroUse" title="MacroUse">page about macro usage</a> for some other high level examples.
</p>
<!-- Saved in parser cache with key wiki:pcache:idhash:975-0!1!0!0!!en!2 and timestamp 20060121124446 -->
<a name="chunk-Grok_Object_oriented_programming"></a>
	  	  <h1 class="firstHeading">Grok Object oriented programming</h1>
	    	    	    <!-- start content -->
	    <p>This page is a part of the <a href="#chunk-Grokking_Nemerle" title="Grokking Nemerle">Grokking Nemerle</a> tutorial.
</p><p>Once again a <a href="http://en.wikipedia.org/wiki/Object-oriented_programming" class="external text" title="http://en.wikipedia.org/wiki/Object-oriented programming">definition</a> from Wikipedia.
</p><p>OOP is all about <a href="http://en.wikipedia.org/wiki/Object_%28computer_science%29" class="external text" title="http://en.wikipedia.org/wiki/Object (computer science)">objects</a>. Objects consist of some data and methods
to operate on this data. In functional programming we have functions
(algorithm) and data. The things are separate. One can think about
objects as of records (structures) with attached functions.
</p><p>Nemerle allows programmers to program in this style. Moreover, the class
library is very deeply object oriented. Therefore OOP is unavoidable
in Nemerle.
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Back_in_the_Refrigerator"><span class="tocnumber">1</span> <span class="toctext">Back in the Refrigerator</span></a></li>
<li class="toclevel-1"><a href="#Inheritance"><span class="tocnumber">2</span> <span class="toctext">Inheritance</span></a></li>
<li class="toclevel-1"><a href="#Virtual_calls"><span class="tocnumber">3</span> <span class="toctext">Virtual calls</span></a></li>
<li class="toclevel-1"><a href="#Interfaces"><span class="tocnumber">4</span> <span class="toctext">Interfaces</span></a></li>
</ul>
</td></tr></tbody></table>
<p><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
</p>
<a name="Back_in_the_Refrigerator"></a><h2> Back in the Refrigerator </h2>
<p>While talking about XML, we have shown an example of a refrigerator. It
was a degenerated object -- a record. Record is a bunch of data, or an
object without methods. Now we will try to extend it a bit.
</p>
<pre class="nemerle"><span style="color: rgb(255, 0, 0);">class</span> Refrigerator
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">mutable</span> minimal_temperature&nbsp;: <span style="color: rgb(255, 0, 0);">float</span>;
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">mutable</span> content&nbsp;: list <span style="color: rgb(0, 0, 0);">[</span>RefrigeratorContent<span style="color: rgb(0, 0, 0);">]</span>;
&nbsp;
  <span style="color: rgb(6, 0, 255);">public</span> AddContent <span style="color: rgb(0, 0, 0);">(</span>elem&nbsp;: RefrigeratorContent<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    content = elem&nbsp;:: content
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
<span style="color: rgb(6, 0, 255);">variant</span> RefrigeratorContent
<span style="color: rgb(0, 0, 0);">{</span>
  | Beer <span style="color: rgb(0, 0, 0);">{</span> name&nbsp;: <span style="color: rgb(255, 0, 0);">string</span>; volume&nbsp;: <span style="color: rgb(255, 0, 0);">float</span>; <span style="color: rgb(0, 0, 0);">}</span>
  | Chips <span style="color: rgb(0, 0, 0);">{</span> weight&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>; <span style="color: rgb(0, 0, 0);">}</span>
  | Ketchup
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>Now, in addition to fields with content and temperature, the refrigerator
has a method for adding new content.
</p><p>The definition of method looks much like the definition of a function
within a module.
</p><p>It is quite important to understand the difference between classes
and objects. Classes are type definitions, while objects (class instances)
are values. Classes define templates to create new objects.
</p><p>Non static methods defined in class <tt>C</tt> have access to a special value
called <tt>this</tt>. It has type <tt>C</tt> and is immutable. It refers to the current
object. You can use the dot (.) operator to access fields of current
object. You can see how <tt>this</tt> is used in the <tt>AddContent</tt> method.
</p><p>The this value is quite often used in object oriented
programming. Therefore it can be omitted for brevity. For example:
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">public</span> AddContent <span style="color: rgb(0, 0, 0);">(</span>elem&nbsp;: RefrigeratorContent<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
<span style="color: rgb(0, 0, 0);">{</span>
  content = elem&nbsp;:: content
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>However, if the method had a formal parameter called content, or a local
value with such a name, one would need to use <tt>this.content</tt> to access
the field.
</p><p>There is one special method in a class called a <i>constructor</i>. It is
called whenever you request creation of new instance of an object. It
the responsibility of the constructor to setup values of all fields
within an object. Fields start with value of <tt>null</tt>, <tt>0</tt> or 
<tt>0.0</tt>.
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">this</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">{</span>
  minimal_temperature = -<span style="color: rgb(255, 0, 0);">273</span>.<span style="color: rgb(255, 0, 0);">15</span>;
  content = <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(0, 0, 0);">]</span>;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>Constructors can take parameters. For example, if we wanted to set
the <tt>minimal_temperature</tt> already at the object construction stage, we
could write:
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">this</span> <span style="color: rgb(0, 0, 0);">(</span>temp&nbsp;: <span style="color: rgb(255, 0, 0);">float</span><span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">{</span>
  minimal_temperature = temp;
  content = <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(0, 0, 0);">]</span>;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>For variant options Nemerle provides a default constructor, that assigns
each field. If you do not provide a constructor for a regular class,
an empty one is generated. If you need the field-assigning constructor,
you can use <tt>[Record]</tt> attribute, like this:
</p>
<pre class="nemerle"><span style="color: rgb(0, 0, 0);">[</span>Record<span style="color: rgb(0, 0, 0);">]</span>
<span style="color: rgb(255, 0, 0);">class</span> Foo
<span style="color: rgb(0, 0, 0);">{</span>
  x&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>;
  y&nbsp;: <span style="color: rgb(255, 0, 0);">float</span>;
  z&nbsp;: <span style="color: rgb(255, 0, 0);">string</span>;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>The following constructor is generated:
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">this</span> <span style="color: rgb(0, 0, 0);">(</span>x&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>, y&nbsp;: <span style="color: rgb(255, 0, 0);">float</span>, z&nbsp;: <span style="color: rgb(255, 0, 0);">string</span><span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">this</span>.x = x;
  <span style="color: rgb(6, 0, 255);">this</span>.y = y;
  <span style="color: rgb(6, 0, 255);">this</span>.z = z;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>The constructor is called with the name of the class when creating new
objects. Other methods are called using the dot operator. For example in
<tt>refr.AddContent (Ketchup ())</tt> the <tt>refr</tt> is passed to the
<tt>AddContent</tt> method as the <tt>this</tt> pointer and <tt>Ketchup
()</tt> is passed as <tt>elem</tt> formal parameter.
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">module</span> Party <span style="color: rgb(0, 0, 0);">{</span>
  Main <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">def</span> refr = Refrigerator <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
    refr.AddContent <span style="color: rgb(0, 0, 0);">(</span>Beer <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"Tiskie"</span>, <span style="color: rgb(255, 0, 0);">0</span>.<span style="color: rgb(255, 0, 0);">60</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>;
    refr.AddContent <span style="color: rgb(0, 0, 0);">(</span>Ketchup <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>Fortunately, objects are not just a fancy notation for a function
application on records.
</p>
<a name="Inheritance"></a><h2> Inheritance </h2>
<p>Classes
can <a href="http://en.wikipedia.org/wiki/Inheritance_%28object-oriented_programming%29" class="external text" title="http://en.wikipedia.org/wiki/Inheritance (object-oriented programming)">inherit</a> 
from other classes. The fact that a class B inherits from a class
A has a few consequences. The first one is that B has now all the fields
and methods of A. The second one is that B is now <b>subtype</b> of A. This
means that all the functions operating on A can now also operate on B.
</p><p>Class A is often called <b>parent</b> or <b>base</b> class of B (which is 
<b>derived</b> class).
</p><p>In the following example we can see how we can call methods defined
in the base class (<tt>AddContent</tt>), as well as from the derived class
(<tt>MoveToBedroom</tt>).
</p><p>Static methods and the constructor are not derived. The parameterless
constructor is defined in this example. As the first thing to do, it
calls parameterless constructor of the base class. It does it, so the
derived fields are initialized first. Then it initializes the new fields.
</p><p>The call to the parameterless parent constructor is in fact
redundant. When there is no call to the parent class constructor, such
a parameterless parent constructor call is assumed in the first line of
a constructor.
</p>
<pre class="nemerle"><span style="color: rgb(255, 0, 0);">class</span> RefrigeratorWithRolls&nbsp;: Refrigerator
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">mutable</span> position_x&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>;
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">mutable</span> position_y&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>;
&nbsp;
  <span style="color: rgb(6, 0, 255);">public</span> MoveBy <span style="color: rgb(0, 0, 0);">(</span>dx&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>, dy&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    position_x += dx;
    position_y += dy;
  <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
  <span style="color: rgb(6, 0, 255);">public</span> MoveToBedroom <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    position_x =  <span style="color: rgb(255, 0, 0);">42</span>;
    position_y = -<span style="color: rgb(255, 0, 0);">42</span>;
  <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">this</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">base</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
    
    position_x = <span style="color: rgb(255, 0, 0);">0</span>;
    position_y = <span style="color: rgb(255, 0, 0);">0</span>;
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
<span style="color: rgb(255, 0, 0);">class</span> TheDayAfter
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">static</span> Main <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">def</span> refr = RefrigeratorWithRolls <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
      <span style="color: rgb(6, 0, 255);">for</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(6, 0, 255);">mutable</span> i = <span style="color: rgb(255, 0, 0);">0</span>; i &lt; <span style="color: rgb(255, 0, 0);">10</span>; ++i<span style="color: rgb(0, 0, 0);">)</span>
      refr.AddContent <span style="color: rgb(0, 0, 0);">(</span>Beer <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"Liech"</span>, <span style="color: rgb(255, 0, 0);">0</span>.<span style="color: rgb(255, 0, 0);">5</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>;
    refr.MoveToBedroom <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
    <span style="color: rgb(0, 128, 128); font-style: italic;">// drink</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<a name="Virtual_calls"></a><h2> Virtual calls </h2>
<p>The funny part begins where objects can react to calling some methods
in a way dependent on the class of the object. It is possible to
define virtual methods, which means they can be redefined in a derived
class. Then when we have a function working on the base class, whenever
it calls the virtual method, an appropriate method is selected base on
actual object type.
</p><p>This feature is called polymorphism in object-oriented world. We will,
however, mostly use this word for another kind of polymorphism --
parametric polymorphism.
</p><p>When one wants to override a virtual method from a base class, it needs
to be declared with the <tt>override</tt> modifier.
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">using</span> <span style="color: rgb(0, 0, 0);">Nemerle</span>.IO;
&nbsp;
<span style="color: rgb(255, 0, 0);">class</span> Refrigerator
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">mutable</span> minimal_temperature&nbsp;: <span style="color: rgb(255, 0, 0);">float</span>;
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">mutable</span> content&nbsp;: list <span style="color: rgb(0, 0, 0);">[</span>RefrigeratorContent<span style="color: rgb(0, 0, 0);">]</span>;
&nbsp;
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">virtual</span> AddContent <span style="color: rgb(0, 0, 0);">(</span>elem&nbsp;: RefrigeratorContent<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    content = elem&nbsp;:: content
  <span style="color: rgb(0, 0, 0);">}</span>
  
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">this</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    minimal_temperature = -<span style="color: rgb(255, 0, 0);">273</span>.<span style="color: rgb(255, 0, 0);">15</span>;
    content = <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(0, 0, 0);">]</span>;
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
<span style="color: rgb(255, 0, 0);">class</span> RestrictedRefrigerator&nbsp;: Refrigerator
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">override</span> AddContent <span style="color: rgb(0, 0, 0);">(</span>elem&nbsp;: RefrigeratorContent<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">match</span> <span style="color: rgb(0, 0, 0);">(</span>elem<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
      | Ketchup =&gt;
        <span style="color: rgb(0, 128, 128); font-style: italic;">// don't add!</span>
        printf <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"Ketchup is not healthy!<span style="color: rgb(0, 128, 128); font-weight: bold;">\n</span>"</span><span style="color: rgb(0, 0, 0);">)</span>
      | _ =&gt;
        content = elem&nbsp;:: content
    <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(0, 0, 0);">}</span>
  
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">this</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>Here we can see how the <tt>AddKetchup</tt> calls different methods
depending on actual object type. The first call adds ketchup, the second
call refuses to do so.
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">module</span> Shop
<span style="color: rgb(0, 0, 0);">{</span>
  AddKetchup <span style="color: rgb(0, 0, 0);">(</span>refr&nbsp;: Refrigerator<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    refr.AddContent <span style="color: rgb(0, 0, 0);">(</span>Ketchup <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
  Main <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">def</span> r1 = Refrigerator <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
    <span style="color: rgb(6, 0, 255);">def</span> r2 = RestrictedRefrigerator <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
    AddKetchup <span style="color: rgb(0, 0, 0);">(</span>r1<span style="color: rgb(0, 0, 0);">)</span>;
    AddKetchup <span style="color: rgb(0, 0, 0);">(</span>r2<span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<a name="Interfaces"></a><h2> Interfaces </h2>
<p>The .NET Framework supports only single inheritance. This means that
any given class can derive from just one base class. However, it is
sometimes needed for a class to be two or more different things depending
on context. .NET supports it (just like Java) through interfaces. An
interface is a contract specifying a set of methods given class should
implement. A class can implement zero or more interfaces (in addition
to deriving from some base class).
</p><p>Implementing interface implies subtyping it. That is if you have a class
A implementing I and method taking I as parameter, then you can pass A
as this parameter.
</p><p>Interfaces most commonly state some ability of type. For example, the
ability to convert itself to some other type or to compare with some
other types.
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">using</span> <span style="color: rgb(0, 0, 0);">Nemerle</span>.IO;
&nbsp;
<span style="color: rgb(255, 0, 0);">interface</span> IPrintable <span style="color: rgb(0, 0, 0);">{</span>
  Print <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>;
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
<span style="color: rgb(255, 0, 0);">class</span> RefrigeratorNG&nbsp;: Refrigerator, IPrintable
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> Print <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    printf <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"I'm the refrigerator!<span style="color: rgb(0, 128, 128); font-weight: bold;">\n</span>"</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">this</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
<span style="color: rgb(6, 0, 255);">module</span> RP <span style="color: rgb(0, 0, 0);">{</span>
  PrintTenTimes <span style="color: rgb(0, 0, 0);">(</span>p&nbsp;: IPrintable<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">for</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(6, 0, 255);">mutable</span> i = <span style="color: rgb(255, 0, 0);">0</span>; i &lt; <span style="color: rgb(255, 0, 0);">10</span>; ++i<span style="color: rgb(0, 0, 0);">)</span>
      p.Print <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">}</span>
  
  Main <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">def</span> refr = RefrigeratorNG <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
    PrintTenTimes <span style="color: rgb(0, 0, 0);">(</span>refr<span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>The base class must come first after the colon in class definition. Then
come interfaces in any order.
</p>
<!-- Saved in parser cache with key wiki:pcache:idhash:976-0!1!0!0!!en!2 and timestamp 20060120211212 -->
<a name="chunk-Grok_Parametric_polymorphism"></a>
	  	  <h1 class="firstHeading">Grok Parametric polymorphism</h1>
	    	    	    <!-- start content -->
	    <p>This page is a part of the <a href="#chunk-Grokking_Nemerle" title="Grokking Nemerle">Grokking Nemerle</a> tutorial.
</p><p><a href="http://en.wikipedia.org/wiki/Polymorphism_%28computer_science%29#Parametric_polymorphism" class="external text" title="http://en.wikipedia.org/wiki/Polymorphism (computer science)#Parametric polymorphism">Parametric polymorphism</a> is a wise way to say that function can operate on
values of any type. Kind of <tt>System.Object</tt>  and/or 
<tt>void*</tt> on steroids. This
is very much like Generics in C# 2.0 or Java 5.0 and somewhat less like
templates in C++.
</p><p>Both functions and types can be parameterized over types.
</p>
<a name="Simple_polymorphism"></a><h2>  Simple polymorphism </h2>
<p>Here we define a list of values of any type (it is also defined in
Nemerle standard library but this is not the point here).
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">variant</span> list <span style="color: rgb(0, 0, 0);">[</span>T<span style="color: rgb(0, 0, 0);">]</span> <span style="color: rgb(0, 0, 0);">{</span>
  | Cons <span style="color: rgb(0, 0, 0);">{</span> hd&nbsp;: T; tl&nbsp;: list <span style="color: rgb(0, 0, 0);">[</span>T<span style="color: rgb(0, 0, 0);">]</span>; <span style="color: rgb(0, 0, 0);">}</span>
  | Nil
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>Here we used <tt>T</tt> as a type parameter to the list type. The
ML-lovers would rather write <tt>'a</tt> instead and read it <i>alpha</i>
(it is a convention to use identifiers starting with an apostrophe for
type parameters). They are allowed to do so, as the apostrophe is allowed
in identifiers in Nemerle. We will however stick to a C++-like convention.
</p><p>In the body of the <tt>list</tt> definition <tt>T</tt> can be used like
any other type name. It is called <b>type variable</b> in this scope.
</p><p>Next we define the method parameterized on a type (it is reflected
by listing <tt>[something]</tt> after <tt>Head</tt>). Since the algorithm 
of taking the head out of the list does not depend on the type of the actual
values stored in the list, we can use the same
<tt>T</tt>, but we could have used <tt>'b</tt> or <tt>foobar42</tt>
as well. This method for <tt>list[int]</tt>, <tt>list[string]</tt> and even
<tt>list[list[int]]</tt> would look exactly the same. Therefore we can
use generic <tt>T</tt> type.
</p><p>You can see that the type of elements of the list (a parameter in
<tt>list[T]</tt>) is used as return type of this method. This way we
can ensure that we take an <tt>int</tt> out of <tt>list[int]</tt> and
not some generic <tt>System.Object</tt>.
</p>
<pre class="nemerle"><span style="color: rgb(255, 0, 0);">class</span> List <span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">static</span> Head<span style="color: rgb(0, 0, 0);">[</span>T<span style="color: rgb(0, 0, 0);">]</span> <span style="color: rgb(0, 0, 0);">(</span>l&nbsp;: list<span style="color: rgb(0, 0, 0);">[</span>T<span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: T
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">match</span> <span style="color: rgb(0, 0, 0);">(</span>l<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
      | Cons <span style="color: rgb(0, 0, 0);">(</span>hd, _<span style="color: rgb(0, 0, 0);">)</span> =&gt; hd
      | Nil =&gt;
        <span style="color: rgb(6, 0, 255);">throw</span> <span style="color: rgb(0, 0, 0);">System</span>.ArgumentException <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
    <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<a name="Constraints_on_type_variables"></a><h2> Constraints on type variables </h2>
<p>It is sometimes necessary for types to be substituted for type variables
to conform to some specific interface. This concept is known as F-bounded
polymorphism. We will address this issue in more detail, as it is probably
new for most readers.
</p><p>For example the elements stored in a tree need to provide a comparison
method. Thus, we can define an appropriate interface and then require
<tt>'a</tt> in <tt>Tree['a]</tt> to conform to it:
</p>
<pre class="nemerle"><span style="color: rgb(255, 0, 0);">interface</span> IComparable <span style="color: rgb(0, 0, 0);">[</span>'a<span style="color: rgb(0, 0, 0);">]</span> <span style="color: rgb(0, 0, 0);">{</span>
  CompareTo <span style="color: rgb(0, 0, 0);">(</span>elem&nbsp;: 'a<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>;
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
<span style="color: rgb(6, 0, 255);">variant</span> Tree<span style="color: rgb(0, 0, 0);">[</span>'a<span style="color: rgb(0, 0, 0);">]</span> 
  <span style="color: rgb(6, 0, 255);">where</span> 'a&nbsp;: IComparable<span style="color: rgb(0, 0, 0);">[</span>'a<span style="color: rgb(0, 0, 0);">]</span>
<span style="color: rgb(0, 0, 0);">{</span>
  | Node <span style="color: rgb(0, 0, 0);">{</span>
      left&nbsp;: Tree<span style="color: rgb(0, 0, 0);">[</span>'a<span style="color: rgb(0, 0, 0);">]</span>;
      elem&nbsp;: 'a;
      right&nbsp;: Tree<span style="color: rgb(0, 0, 0);">[</span>'a<span style="color: rgb(0, 0, 0);">]</span>;
    <span style="color: rgb(0, 0, 0);">}</span>
  | Tip
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>In fact the <tt>IComparable</tt> interface is already defined in the standard
library, but that is not the point.
</p><p>Now, once we ensured that elements in the tree conform to
<tt>IComparable</tt>, we can use the <tt>CompareTo</tt> method. For
example, to insert a thing into the tree we can use the following
function:
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">module</span> TreeOperations <span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> Insert<span style="color: rgb(0, 0, 0);">[</span>'a<span style="color: rgb(0, 0, 0);">]</span> <span style="color: rgb(0, 0, 0);">(</span>t&nbsp;: Tree<span style="color: rgb(0, 0, 0);">[</span>'a<span style="color: rgb(0, 0, 0);">]</span>, e&nbsp;: 'a<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: Tree<span style="color: rgb(0, 0, 0);">[</span>'a<span style="color: rgb(0, 0, 0);">]</span>
    <span style="color: rgb(6, 0, 255);">where</span> 'a&nbsp;: IComparable<span style="color: rgb(0, 0, 0);">[</span>'a<span style="color: rgb(0, 0, 0);">]</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">match</span> <span style="color: rgb(0, 0, 0);">(</span>t<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
      | Node <span style="color: rgb(0, 0, 0);">(</span>l, c, r<span style="color: rgb(0, 0, 0);">)</span> =&gt;
        <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>e.CompareTo <span style="color: rgb(0, 0, 0);">(</span>c<span style="color: rgb(0, 0, 0);">)</span> &lt; <span style="color: rgb(255, 0, 0);">0</span><span style="color: rgb(0, 0, 0);">)</span>
          Node <span style="color: rgb(0, 0, 0);">(</span>Insert <span style="color: rgb(0, 0, 0);">(</span>l, e<span style="color: rgb(0, 0, 0);">)</span>, c, r<span style="color: rgb(0, 0, 0);">)</span>
        <span style="color: rgb(6, 0, 255);">else</span> <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>e.CompareTo <span style="color: rgb(0, 0, 0);">(</span>c<span style="color: rgb(0, 0, 0);">)</span> &gt; <span style="color: rgb(255, 0, 0);">0</span><span style="color: rgb(0, 0, 0);">)</span>
          Node <span style="color: rgb(0, 0, 0);">(</span>r, c, Insert <span style="color: rgb(0, 0, 0);">(</span>r, e<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
        <span style="color: rgb(6, 0, 255);">else</span>
          Node <span style="color: rgb(0, 0, 0);">(</span>r, e, l<span style="color: rgb(0, 0, 0);">)</span>
      | Tip =&gt;
        Node <span style="color: rgb(0, 0, 0);">(</span>Tip <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>, e, Tip <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
    <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>The people familiar with C# or Java will ask why not simply use something
like:
</p>
<pre class="nemerle"><span style="color: rgb(255, 0, 0);">interface</span> IComparable <span style="color: rgb(0, 0, 0);">{</span>
  CompareTo <span style="color: rgb(0, 0, 0);">(</span>elem&nbsp;: IComparable<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>;
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
<span style="color: rgb(6, 0, 255);">variant</span> Tree
<span style="color: rgb(0, 0, 0);">{</span>
  | Node <span style="color: rgb(0, 0, 0);">{</span>
      left&nbsp;: Tree;
      elem&nbsp;: IComparable;
      right&nbsp;: Tree;
    <span style="color: rgb(0, 0, 0);">}</span>
  | Tip
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>But this is only half good. The most often case for using a tree is
to store elements of some specific type, for example strings. We don't
want integers and strings to be stored in the same tree, for the very
simple reason that we cannot compare integer with string in a reasonable
way. Well, even if we could, we plainly cannot predict what other types
beside integers and strings implement <tt>IComparable</tt> and thus can
be passed to string's <tt>CompareTo</tt>.
</p><p>But the design above makes it impossible to ensure statically whether
we're using the tree with correct types. When inserting nodes to the tree
we upcast them all to <tt>IComparable</tt>. We will get runtime exception
when string's <tt>CompareTo</tt> is passed integer argument. The second
drawback is that when we extract elements out of the tree, we need
to downcast them to a specific type. This is second possibility for
runtime errors.
</p><p>To fully understand this issue please look at the following example:
</p>
<pre class="nemerle"><span style="color: rgb(255, 0, 0);">interface</span> IFrobincatable <span style="color: rgb(0, 0, 0);">{</span>
  Frobnicate <span style="color: rgb(0, 0, 0);">(</span>x&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>;
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
<span style="color: rgb(255, 0, 0);">class</span> C1&nbsp;: IFrobincatable 
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">this</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span><span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(6, 0, 255);">public</span> Frobnicate <span style="color: rgb(0, 0, 0);">(</span>_&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span> <span style="color: rgb(0, 0, 0);">{</span><span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
<span style="color: rgb(255, 0, 0);">class</span> C2&nbsp;: IFrobincatable 
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">this</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span><span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(6, 0, 255);">public</span> Frobnicate <span style="color: rgb(0, 0, 0);">(</span>_&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span> <span style="color: rgb(0, 0, 0);">{</span><span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
<span style="color: rgb(6, 0, 255);">module</span> M <span style="color: rgb(0, 0, 0);">{</span>
  f1<span style="color: rgb(0, 0, 0);">[</span>'a<span style="color: rgb(0, 0, 0);">]</span> <span style="color: rgb(0, 0, 0);">(</span>o&nbsp;: 'a<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: 'a
    <span style="color: rgb(6, 0, 255);">where</span> 'a&nbsp;: IFrobincatable
  <span style="color: rgb(0, 0, 0);">{</span>
    o.Frobnicate <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">3</span><span style="color: rgb(0, 0, 0);">)</span>;
    o
  <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
  f2 <span style="color: rgb(0, 0, 0);">(</span>o&nbsp;: IFrobincatable<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: IFrobincatable
  <span style="color: rgb(0, 0, 0);">{</span>
    o.Frobnicate <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">3</span><span style="color: rgb(0, 0, 0);">)</span>;
    C1 <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
  Main <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">def</span> x1 = f1 <span style="color: rgb(0, 0, 0);">(</span>C1 <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>; <span style="color: rgb(0, 128, 128); font-style: italic;">// x1&nbsp;: C1</span>
    <span style="color: rgb(6, 0, 255);">def</span> x2 = f1 <span style="color: rgb(0, 0, 0);">(</span>C2 <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>; <span style="color: rgb(0, 128, 128); font-style: italic;">// x2&nbsp;: C2</span>
    <span style="color: rgb(6, 0, 255);">def</span> x3 = f2 <span style="color: rgb(0, 0, 0);">(</span>C1 <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>; <span style="color: rgb(0, 128, 128); font-style: italic;">// x3&nbsp;: IFrobincatable</span>
    <span style="color: rgb(6, 0, 255);">def</span> x4 = f2 <span style="color: rgb(0, 0, 0);">(</span>C2 <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>; <span style="color: rgb(0, 128, 128); font-style: italic;">// x4&nbsp;: IFrobincatable</span>
&nbsp;
    <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>In the <tt>Main</tt> function you can see what types get the 
<tt>x1</tt>, <tt>x2</tt> etc values.
</p>
<!-- Saved in parser cache with key wiki:pcache:idhash:977-0!1!0!0!!en!2 and timestamp 20060120214137 -->
<a name="chunk-Grok_Exceptions"></a>
	  	  <h1 class="firstHeading">Grok Exceptions</h1>
	    	    	    <!-- start content -->
	    <p>This page is a part of the <a href="#chunk-Grokking_Nemerle" title="Grokking Nemerle">Grokking Nemerle</a> tutorial.
</p><p>In Nemerle you can use exceptions in a similar way you would use them
in C#. The only difference is the syntax for the catch  handlers --
it looks more or less like matching, you can even use the <tt>_</tt> to denote
any exception that has to be caught.
</p>
<pre class="nemerle">some_function <span style="color: rgb(0, 0, 0);">(</span>foo&nbsp;: <span style="color: rgb(255, 0, 0);">string</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">when</span> <span style="color: rgb(0, 0, 0);">(</span>foo == <span style="color: rgb(6, 0, 255);">null</span><span style="color: rgb(0, 0, 0);">)</span>
    <span style="color: rgb(6, 0, 255);">throw</span> <span style="color: rgb(0, 0, 0);">System</span>.ArgumentException <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"foo"</span><span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(0, 128, 128); font-style: italic;">// do something</span>
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
some_other_function <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">try</span> <span style="color: rgb(0, 0, 0);">{</span>
    some_function <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">}</span> 
  <span style="color: rgb(6, 0, 255);">catch</span> <span style="color: rgb(0, 0, 0);">{</span>
    | e <span style="color: rgb(0, 128, 0);">is</span> <span style="color: rgb(0, 0, 0);">System</span>.ArgumentException =&gt;
      printf <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"a problem:<span style="color: rgb(0, 128, 128); font-weight: bold;">\n</span>%s<span style="color: rgb(0, 128, 128); font-weight: bold;">\n</span>"</span>, e.Message<span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">}</span> 
  <span style="color: rgb(6, 0, 255);">finally</span> <span style="color: rgb(0, 0, 0);">{</span>
    printf <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"yikes"</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
some_other_function_<span style="color: rgb(255, 0, 0);">2</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">try</span> <span style="color: rgb(0, 0, 0);">{</span>
    some_function <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">}</span> <span style="color: rgb(6, 0, 255);">catch</span> <span style="color: rgb(0, 0, 0);">{</span>
    | e <span style="color: rgb(0, 128, 0);">is</span> <span style="color: rgb(0, 0, 0);">System</span>.ArgumentException =&gt;
      printf <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"invalid argument<span style="color: rgb(0, 128, 128); font-weight: bold;">\n</span>"</span><span style="color: rgb(0, 0, 0);">)</span>
    | _ =&gt;
    <span style="color: rgb(0, 128, 128); font-style: italic;">// just like:</span>
    <span style="color: rgb(0, 128, 128); font-style: italic;">// | _ is System.Exception =&gt;</span>
      printf <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"a problem<span style="color: rgb(0, 128, 128); font-weight: bold;">\n</span>"</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
some_other_function_<span style="color: rgb(255, 0, 0);">3</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">def</span> f = open_file <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(6, 0, 255);">try</span> <span style="color: rgb(0, 0, 0);">{</span>
    some_function <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">}</span> 
  <span style="color: rgb(6, 0, 255);">finally</span> <span style="color: rgb(0, 0, 0);">{</span>
    f.close <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
<span style="color: rgb(255, 0, 0);">class</span> MyException&nbsp;: <span style="color: rgb(0, 0, 0);">System</span>.Exception <span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">this</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span><span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>

<!-- Saved in parser cache with key wiki:pcache:idhash:978-0!1!0!0!!en!2 and timestamp 20060120214145 -->
<a name="chunk-Grok_Properties,_indexers,_delegates_and_events"></a>
	  	  <h1 class="firstHeading">Grok Properties, indexers, delegates and events</h1>
	    	    	    <!-- start content -->
	    <p>This page is a part of the <a href="#chunk-Grokking_Nemerle" title="Grokking Nemerle">Grokking Nemerle</a> tutorial.
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Properties"><span class="tocnumber">1</span> <span class="toctext">Properties</span></a></li>
<li class="toclevel-1"><a href="#Indexers"><span class="tocnumber">2</span> <span class="toctext">Indexers</span></a></li>
<li class="toclevel-1"><a href="#Delegates"><span class="tocnumber">3</span> <span class="toctext">Delegates</span></a></li>
<li class="toclevel-1"><a href="#Events"><span class="tocnumber">4</span> <span class="toctext">Events</span></a></li>
</ul>
</td></tr></tbody></table>
<p><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
</p>
<a name="Properties"></a><h2> Properties </h2>
<p>Properties are syntactic sugar for get/set design pattern commonly found
in Java. Accessing a property looks like accessing a field, but under
the hood it is translated to a method call.
</p>
<pre class="nemerle"><span style="color: rgb(255, 0, 0);">class</span> Button <span style="color: rgb(0, 0, 0);">{</span>
  text&nbsp;: <span style="color: rgb(255, 0, 0);">string</span>;
  <span style="color: rgb(6, 0, 255);">public</span> Text&nbsp;: <span style="color: rgb(255, 0, 0);">string</span> <span style="color: rgb(0, 0, 0);">{</span>
    get <span style="color: rgb(0, 0, 0);">{</span> text <span style="color: rgb(0, 0, 0);">}</span>
    set <span style="color: rgb(0, 0, 0);">{</span> text = value; Redraw <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
<span style="color: rgb(6, 0, 255);">def</span> b = Button <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
b.Text = b.Text + <span style="color: rgb(128, 128, 128);">"..."</span></pre>
<a name="Indexers"></a><h2> Indexers </h2>
<p>Indexers are other form of properties, but instead of exposing field
access syntax array access syntax is used. All .NET indexers have names,
though one indexer can be marked as the <b>default indexer</b> (well, in
fact one name of indexer is marked as default, but there can be several
indexers with that name, subject to the regular overloading rules).
</p><p>For example the <tt>System.Hashtable</tt> default indexer is called
<tt>Item</tt> and <tt>System.String</tt> one is called <tt>Chars</tt>. The
C# language allows definition of default indexer only. Nemerle allows
also other indexers (like VB.NET). In the current release default indexer
is always <tt>Item</tt>.
</p>
<pre class="nemerle"><span style="color: rgb(255, 0, 0);">class</span> Table <span style="color: rgb(0, 0, 0);">{</span>
  store&nbsp;: <span style="color: rgb(6, 0, 255);">array</span> <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(6, 0, 255);">array</span> <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">string</span><span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">]</span>;
  <span style="color: rgb(6, 0, 255);">public</span> Item <span style="color: rgb(0, 0, 0);">[</span>row&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>, column&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">]</span>&nbsp;: <span style="color: rgb(255, 0, 0);">string</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    get <span style="color: rgb(0, 0, 0);">{</span> store<span style="color: rgb(0, 0, 0);">[</span>row<span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">[</span>column<span style="color: rgb(0, 0, 0);">]</span> <span style="color: rgb(0, 0, 0);">}</span>
    set <span style="color: rgb(0, 0, 0);">{</span> store<span style="color: rgb(0, 0, 0);">[</span>row<span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">[</span>column<span style="color: rgb(0, 0, 0);">]</span> = value <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
<span style="color: rgb(6, 0, 255);">def</span> t = Table <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
t<span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">2</span>, <span style="color: rgb(255, 0, 0);">3</span><span style="color: rgb(0, 0, 0);">]</span> = <span style="color: rgb(128, 128, 128);">"foo"</span>;
t<span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">2</span>, <span style="color: rgb(255, 0, 0);">2</span><span style="color: rgb(0, 0, 0);">]</span></pre>
<a name="Delegates"></a><h2> Delegates </h2>
<p>Delegates are half-baked functional values. In fact there is little place
for usage of delegates in Nemerle itself. However other .NET languages
all speak delegates, so they are good way to expose functional values
for them and <i>vice versa</i>.
</p><p>Delegates are in essence named functional types. They are defined with
<tt>delegate</tt> keyword:
</p>
<pre class="nemerle"><span style="color: rgb(255, 0, 0);">delegate</span> Foo <span style="color: rgb(0, 0, 0);">(</span>_&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>, _&nbsp;: <span style="color: rgb(255, 0, 0);">string</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>;
<span style="color: rgb(255, 0, 0);">delegate</span> Callback <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>;</pre>
<p>Later delegate name can be used to construct delegate instances. Any
functional value of corresponding type can be used to create delegate
instance (local functions and lambda expressions in particular).
</p><p>Delegate instance can be invoked using regular function call syntax,
as well as the <tt>Invoke</tt> special method. Please consult class library
documentation for details.
</p><p>The <tt>+=</tt> operator has special meaning on delegate instances --
it calls the <tt>System.Delegate.Combine</tt> method that makes one
function that calls two other in sequence. This operator is probably
more useful with events.
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">module</span> X <span style="color: rgb(0, 0, 0);">{</span>
  some_fun <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">mutable</span> f = Foo <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(6, 0, 255);">fun</span> <span style="color: rgb(0, 0, 0);">(</span>_, _<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span><span style="color: rgb(0, 0, 0);">}</span><span style="color: rgb(0, 0, 0);">)</span>;
    f <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">3</span>, <span style="color: rgb(128, 128, 128);">"foo"</span><span style="color: rgb(0, 0, 0);">)</span>; <span style="color: rgb(0, 128, 128); font-style: italic;">// same as f.Invoke (3, "foo");</span>
    f += <span style="color: rgb(6, 0, 255);">fun</span> <span style="color: rgb(0, 0, 0);">(</span>_, s<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span> <span style="color: rgb(0, 0, 0);">System</span>.Console.WriteLine <span style="color: rgb(0, 0, 0);">(</span>s<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">}</span>;
    f <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">42</span>, <span style="color: rgb(128, 128, 128);">"bar"</span><span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<a name="Events"></a><h2> Events </h2>
<p>Events are kind of specialized properties for delegates. They are used
in a GUI system for connecting signals (setting function to call when
a button is pressed etc.). They can be also used to call user defined
function on certain events, like class being loaded by the runtime system.
</p><p>Events are defined like fields, but they are marked with the
<tt>event</tt> keyword, and always have a delegate type. Inside the class
events are seen as fields of these delegate type, but outside only the
<tt>+=</tt> and <tt>-=</tt> operators are available. They are used to
connect and disconnect delegates. Implicit conversion from functional
values to delegate instances is provided.
</p><p><br>
</p>
<pre class="nemerle"><span style="color: rgb(255, 0, 0);">class</span> Button <span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">event</span> OnClick&nbsp;: Callback;
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
<span style="color: rgb(6, 0, 255);">def</span> b = Button <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
b.OnClick += <span style="color: rgb(6, 0, 255);">fun</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span> ... <span style="color: rgb(0, 0, 0);">}</span></pre>

<!-- Saved in parser cache with key wiki:pcache:idhash:979-0!1!0!0!!en!2 and timestamp 20060120214155 -->
</body></html>