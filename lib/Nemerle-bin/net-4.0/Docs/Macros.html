<html><head>
  
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Nemerle Offline Documentation</title>
    <style type="text/css" media="screen,projection">
body {
    font: x-small sans-serif;
    background: #eee ;
    color: Black;
}
a {
    text-decoration: none;
    font-weight: bold;
    color: #25e;
    background: none;
}

a:visited { color: #63f/*#863*/; }
a:active { color: #ffa500; }
a:hover { text-decoration: underline; color: red; }

hr {
    height: 1px;
    color: #aaaaaa;
    background-color: #aaaaaa;
    border: 0;
    margin: 0.2em 0 0.2em 0;
}

h1, h2, h3, h4, h5, h6 {
    color: black;
    background: none;
    font-weight: bold;
    margin: 0;
    padding-top: 0.5em;
    padding-bottom: 0.17em;
    border-bottom: 1px solid #222;
}
h1 { font: bold 188% sans-serif; }
h2 { font: bold 150% sans-serif; }
h3 {
    border-bottom: 1px solid #aaa;
}
h4, h5, h6 {
    border-bottom: none;
}
h3 { font-size: 132%; }
h4 { font-size: 116%; }
h5 { font-size: 100%; }
h6 { font-size: 80%;  }

ul {
    line-height: 1.5em;
    list-style-type: square;
    margin: 0.3em 0 0 1.5em;
    padding:0;
}
ol {
    line-height: 1.5em;
    margin: 0.3em 0 0 3.2em;
    padding:0;
    list-style-image: none;
}
li { margin-bottom: 0.1em; }
dt {
    font-weight: bold;
    margin-bottom: 0.1em;
}
dl{
    margin-top: 0.2em;
    margin-bottom: 0.5em;
}
dd {
    line-height: 1.5em;
    margin-left: 2em;
    margin-bottom: 0.1em;
}
code { background-color: #f9f9f9; }
pre {
    padding: 1em;
    border: 1px dashed #2f6fab;
    color: Black;
    background-color: #f9f9f9;
    line-height: 1.1em;
}

#toc {
    /*border:1px solid #2f6fab;*/
    border:1px solid #aaaaaa;
    background-color:#f9f9f9;
    padding:5px;
    font-size: 95%;
    margin: 2em;
}
    </style>
  </head><body>


<a name="chunk-Macros"></a>
	  	  <h1 class="firstHeading">Macros</h1>
	    	    	    <!-- start content -->
	    <table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Intro"><span class="tocnumber">1</span> <span class="toctext">Intro</span></a></li>
<li class="toclevel-1"><a href="#Key_features"><span class="tocnumber">2</span> <span class="toctext">Key features</span></a></li>
<li class="toclevel-1"><a href="#Using_macros"><span class="tocnumber">3</span> <span class="toctext">Using macros</span></a></li>
<li class="toclevel-1"><a href="#Writing_macros"><span class="tocnumber">4</span> <span class="toctext">Writing macros</span></a></li>
</ul>
</td></tr></tbody></table>
<p><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
</p>
<a name="Intro"></a><h2> Intro </h2>
<p>You can think about macros as of a system of compile-time transformations 
and automatic generation of code with regard to some rules. 
It can be used either to automate manipulations performed on similar
data-types and fragments of code or to add syntax shortcuts to the language,
optimize and make some computations safer by moving them from runtime
to compile-time.
</p><p>The idea of making simple inline operations on the code comes from preprocessor
macros, which many languages (especially C, C++) have contained since early 
times of compiler design. We are following them in the direction of much more
powerful, and at the same time more secure (type-safe) solutions
like Haskell Template Meta-programming.
</p>
<a name="Key_features"></a><h2> Key features </h2>
<ul><li>built-in ability of extending language syntax
</li><li>algorithmic generation of code, which may be dependent on
external factors, like XML files, script programs, databases or even
remote web sites
</li><li>completing datatypes with automatically created methods for
performing arbitrary operations, e.g. reading datasets from a file,
sending them through the network or storing in an SQL database
</li><li>using the context of compilation provided by compiler's
internal structures, like line numbers (for error reporting), names of
processed type, function, class or namespace and accessing datatype
definitions by name
</li><li>creating functions, whose amount and type of arguments depend
on each other (like C printf) with full type-checking during
compile-time
</li></ul>
<a name="Using_macros"></a><h2> Using macros </h2>
<p>You can take a look at the most <a href="#chunk-MacroUse" title="MacroUse">appealing examples</a>
of macro use. It contains a description of how we incorporate
methodologies as Design By Contract, compile-time verification of SQL
statements and Aspects-Oriented Programming into Nemerle.
</p><p>Most useful macros usually gets into the standard tool library
of application. Nemerle compiler also have such macros, and they are by
default available together with the distribution. Their list is kept on
<a href="http://wiki.nemerle.org/Class_library#macro_packages" title="Class library">class library</a> page.
</p>
<a name="Writing_macros"></a><h2> Writing macros </h2>
<ul><li><a href="#chunk-Macros_tutorial" title="Macros tutorial">Macros tutorial</a> describing how to begin writing macros
</li><li><a href="#chunk-Partial_evaluation" title="Partial evaluation">Partial evaluation</a> tutorial and examples.
</li><li><a href="http://wiki.nemerle.org/Simple_expression_evaluator" title="Simple expression evaluator">Simple expression evaluator</a> example
</li><li>Automating code generation in <a href="#chunk-Design_patterns" title="Design patterns">design patterns</a> usage.
</li><li><a href="#chunk-Syntax_extensions" title="Syntax extensions">Syntax extensions</a> description.
</li><li>Some <a href="#chunk-Macro_tips" title="Macro tips">tips</a> for macro writers.
</li><li><a href="#chunk-Defining_types_from_inside_macros" title="Defining types from inside macros">Defining types from inside macros</a>
</li></ul>

<!-- Saved in parser cache with key wiki:pcache:idhash:1006-0!1!0!0!!en!2 and timestamp 20060121083512 -->
<a name="chunk-MacroUse"></a>
	  	  <h1 class="firstHeading">MacroUse</h1>
	    	    	    <!-- start content -->
	    <p><b>The most interesting features we implemented using macros</b>
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a></li>
<li class="toclevel-1"><a href="#Design_by_contract"><span class="tocnumber">2</span> <span class="toctext">Design by contract</span></a></li>
<li class="toclevel-1"><a href="#Compile-time_validation_of_embedded_languages"><span class="tocnumber">3</span> <span class="toctext">Compile-time validation of embedded languages</span></a></li>
<li class="toclevel-1"><a href="#Partial_evaluation"><span class="tocnumber">4</span> <span class="toctext">Partial evaluation</span></a></li>
<li class="toclevel-1"><a href="#Concurrency_constructs"><span class="tocnumber">5</span> <span class="toctext">Concurrency constructs</span></a></li>
<li class="toclevel-1"><a href="#Design_patterns"><span class="tocnumber">6</span> <span class="toctext">Design patterns</span></a></li>
<li class="toclevel-1"><a href="#Aspects-Oriented_programming"><span class="tocnumber">7</span> <span class="toctext">Aspects-Oriented programming</span></a></li>
<li class="toclevel-1"><a href="#More"><span class="tocnumber">8</span> <span class="toctext">More</span></a></li>
</ul>
</td></tr></tbody></table>
<p><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
</p>
<a name="Introduction"></a><h2> Introduction </h2>
<p>This page is dedicated to the features of Nemerle and its library, which
have been implemented using our <a href="#chunk-Macros" title="Macros">meta-programming facilities</a>.
</p><p>Understanding how macros work is not necessary for using any of
them. It would be useful only for knowing that those examples 
are just a tip of an iceberg called meta-programming and that you can easily
implement even nicer things.
</p><p>Please refer to <a href="http://wiki.nemerle.org/Class_library" title="Class library">class library</a> documentation for a reference list of
implemented macros.
</p>
<a name="Design_by_contract"></a><h2> Design by contract </h2>
<p>Languages like <a href="http://en.wikipedia.org/wiki/Eiffel_programming_language" class="external text" title="http://en.wikipedia.org/wiki/Eiffel programming language">Eiffel</a>
or <a href="http://research.microsoft.com/%7Eleino/papers/krml136.pdf" class="external text" title="http://research.microsoft.com/~leino/papers/krml136.pdf">Spec#</a> incorporate a
methodology called <a href="http://en.wikipedia.org/wiki/Design_by_contract" class="external text" title="http://en.wikipedia.org/wiki/Design by contract">Design by Contract</a> 
to reason about programs, libraries, methods. It allows to write more
secure and correct software and specify its behavior.
</p><p>A quick example below shows how it looks in Nemerle with its syntax extensions. Note that
the <b>invariant</b>, <b>requires</b> and <b>ensures</b> syntax is added to the scope by opening 
<i>Nemerle.Assertions</i> namespace containing design by contract macros.
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">using</span> <span style="color: rgb(0, 0, 0);">Nemerle</span>.Assertions;
&nbsp;
<span style="color: rgb(255, 0, 0);">class</span> BeerControl 
invariant m_temperature &lt;= <span style="color: rgb(255, 0, 0);">6</span>.<span style="color: rgb(255, 0, 0);">0</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> DrinkUsingAStraw <span style="color: rgb(0, 0, 0);">(</span>how_much&nbsp;: <span style="color: rgb(255, 0, 0);">float</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
  requires how_much &gt; <span style="color: rgb(255, 0, 0);">0</span>.<span style="color: rgb(255, 0, 0);">0</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    m_amount -= how_much
  <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
  <span style="color: rgb(6, 0, 255);">public</span> DissipationHandler <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
  ensures m_amount &gt; <span style="color: rgb(255, 0, 0);">0</span>.<span style="color: rgb(255, 0, 0);">0</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">when</span> <span style="color: rgb(0, 0, 0);">(</span>AReallySmallNumber &lt; m_amount<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
      m_temperature += <span style="color: rgb(0, 0, 0);">(</span>Room.Temperature - m_temperature<span style="color: rgb(0, 0, 0);">)</span> / <span style="color: rgb(255, 0, 0);">100</span>.<span style="color: rgb(255, 0, 0);">0</span>;
      m_amount -= <span style="color: rgb(255, 0, 0);">0</span>.<span style="color: rgb(255, 0, 0);">1</span>; <span style="color: rgb(0, 128, 128); font-style: italic;">// loss due to the evaporation</span>
    <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(0, 0, 0);">}</span>
  
  <span style="color: rgb(6, 0, 255);">private</span> <span style="color: rgb(6, 0, 255);">mutable</span> m_temperature&nbsp;: <span style="color: rgb(255, 0, 0);">float</span>;
  <span style="color: rgb(6, 0, 255);">private</span> <span style="color: rgb(6, 0, 255);">mutable</span> m_amount&nbsp;: <span style="color: rgb(255, 0, 0);">float</span>;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>See here for <a href="http://wiki.nemerle.org/Design_by_contract_macros" title="Design by contract macros">more...</a>
</p>
<a name="Compile-time_validation_of_embedded_languages"></a><h2> Compile-time validation of embedded languages </h2>
<p>In many programming tasks there is a need for using
<a href="http://en.wikipedia.org/wiki/Domain-specific_language" class="external text" title="http://en.wikipedia.org/wiki/Domain-specific language">domain-specific languages</a>
for performing some specialized operations. The examples are
regular expressions used for searching and matching parts of text, formatting
strings of <tt>printf</tt> function or SQL for obtaining data from database.
All those languages have their own syntax and validity rules. 
</p><p>Most of DSLs are used inside a general-purpose language by embedding programs written in them
into strings. For example, to query a database about elements in some table, one writes an SQL
statement and sends it to the database provider as a string. The common problem with this approach
is verifying correctness of embedded programs - if the syntax is valid, if  types of the 
variables used match, etc. Unfortunately, in most cases all those checks are performed at runtime,
when a particular program is expected to execute, but fails with a syntax or invalid cast error.
</p><p>All this happen, because the compiler of our general-purpose language treats DSL programs just
as common strings. It is not surprising though - it was not designed to verify any
particular domain-specific language - but it would be nice to do it before runtime. 
In Nemerle we can use macros to
handle some of the strings in a special way - for example run a verification function against
them.
</p><p>This mechanism is very general and it is used in some parts of Nemerle standard library
(like regular expression matching, printf-like functions). Please refer to our <a href="http://wiki.nemerle.org/SQL_macros" title="SQL macros">SQL macros</a>
description for more information.
</p>
<a name="Partial_evaluation"></a><h2> Partial evaluation </h2>
<p><a href="http://en.wikipedia.org/wiki/Partial_evaluation" class="external text" title="http://en.wikipedia.org/wiki/Partial evaluation">Partial evaluation</a>
is a process of specializing given program with some of its inputs,
which are known statically. This way we obtain a new program, which is
the optimized version of the general one. Implementation of this
technique often involves program generation and rewriting.
</p><p>Macros can be used as a convenient tool for partial evaluation in 
a similar way to 
<a href="http://www.cse.ogi.edu/PacSoft/publications/phaseiiiq8papers/metaml.pdf" class="external text" title="http://www.cse.ogi.edu/PacSoft/publications/phaseiiiq8papers/metaml.pdf">multi-stage programming</a>.
</p><p>A <a href="#chunk-Partial_evaluation" title="Partial evaluation">tutorial</a>
explains how to use macros in such a setting. There are examples
describing specialization technique (power function, permutation
algorithm) and others.
</p>
<a name="Concurrency_constructs"></a><h2> Concurrency constructs </h2>
<p>Most of the features of 
<a href="http://research.microsoft.com/%7Enick/polyphony/" class="external text" title="http://research.microsoft.com/~nick/polyphony/">Polyphonic C#</a>
were implemented in our library using Nemerle macros. You can use these specialized
features for safer multithreading application, by simply importing
Nemerle.Concurrency namespace.  
</p><p>Currently you can see some
<a href="http://nemerle.org/svn/nemerle/trunk/snippets/concurrency/" class="external text" title="http://nemerle.org/svn/nemerle/trunk/snippets/concurrency/">examples</a>.        
</p>
<a name="Design_patterns"></a><h2> Design patterns </h2>
<p>Some <a href="#chunk-Design_patterns" title="Design patterns">design patterns</a>
can be greatly automated by macros. Instead of writing massive amount
of code, programmer can just generate neccessary methods, fields, etc.
or transform handwritten classes according to the needs, reducing
maintainance costs and bugs introduced
by commonly used copy &amp; paste method.
</p><p><br>	
</p>
<a name="Aspects-Oriented_programming"></a><h2> Aspects-Oriented programming </h2>
<p>As for now see 
<a href="http://nemerle.org/svn/nemerle/trunk/ncc/testsuite/positive/trace.n" class="external text" title="http://nemerle.org/svn/nemerle/trunk/ncc/testsuite/positive/trace.n">this</a>.
</p>
<a name="More"></a><h2> More </h2>
<p>More examples can be found at the <a href="http://wiki.nemerle.org/Class_library" title="Class library">class library</a> documentation page.
</p>
<!-- Saved in parser cache with key wiki:pcache:idhash:990-0!1!0!0!!en!2 and timestamp 20060121061921 -->
<a name="chunk-Macros_tutorial"></a>
	  	  <h1 class="firstHeading">Macros tutorial</h1>
	    	    	    <!-- start content -->
	    <p><b>Nemerle type-safe macros</b>
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#What_exactly_is_a_macro.3F"><span class="tocnumber">1</span> <span class="toctext">What exactly is a macro?</span></a></li>
<li class="toclevel-1"><a href="#Defining_a_new_macro"><span class="tocnumber">2</span> <span class="toctext">Defining a new macro</span></a>
<ul>
<li class="toclevel-2"><a href="#Compiling_a_simplest_macro"><span class="tocnumber">2.1</span> <span class="toctext">Compiling a simplest macro</span></a></li>
<li class="toclevel-2"><a href="#Exercise"><span class="tocnumber">2.2</span> <span class="toctext">Exercise</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Operating_on_syntax_trees"><span class="tocnumber">3</span> <span class="toctext">Operating on syntax trees</span></a>
<ul>
<li class="toclevel-2"><a href="#Quotation_operator"><span class="tocnumber">3.1</span> <span class="toctext">Quotation operator</span></a></li>
<li class="toclevel-2"><a href="#Matching_subexpressions"><span class="tocnumber">3.2</span> <span class="toctext">Matching subexpressions</span></a></li>
<li class="toclevel-2"><a href="#Base_elements_of_grammar"><span class="tocnumber">3.3</span> <span class="toctext">Base elements of grammar</span></a></li>
<li class="toclevel-2"><a href="#Constructs_with_variable_amount_of_elements"><span class="tocnumber">3.4</span> <span class="toctext">Constructs with variable amount of elements</span></a></li>
<li class="toclevel-2"><a href="#Exercise_2"><span class="tocnumber">3.5</span> <span class="toctext">Exercise</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Adding_new_syntax_to_the_compiler"><span class="tocnumber">4</span> <span class="toctext">Adding new syntax to the compiler</span></a>
<ul>
<li class="toclevel-2"><a href="#Exercise_3"><span class="tocnumber">4.1</span> <span class="toctext">Exercise</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Macros_in_custom_attributes"><span class="tocnumber">5</span> <span class="toctext">Macros in custom attributes</span></a>
<ul>
<li class="toclevel-2"><a href="#Executing_macros_on_type_declarations"><span class="tocnumber">5.1</span> <span class="toctext">Executing macros on type declarations</span></a></li>
<li class="toclevel-2"><a href="#Manipulating_type_declarations"><span class="tocnumber">5.2</span> <span class="toctext">Manipulating type declarations</span></a></li>
<li class="toclevel-2"><a href="#Execution_stages"><span class="tocnumber">5.3</span> <span class="toctext">Execution stages</span></a>
<ul>
<li class="toclevel-3"><a href="#Parameters_of_attribute_macros"><span class="tocnumber">5.3.1</span> <span class="toctext">Parameters of attribute macros</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#Reference_to_more_advanced_aspects"><span class="tocnumber">6</span> <span class="toctext">Reference to more advanced aspects</span></a>
<ul>
<li class="toclevel-2"><a href="#Hygiene_and_alpha-renaming_of_identifiers"><span class="tocnumber">6.1</span> <span class="toctext">Hygiene and alpha-renaming of identifiers</span></a>
<ul>
<li class="toclevel-3"><a href="#Problem_with_names_capture"><span class="tocnumber">6.1.1</span> <span class="toctext">Problem with names capture</span></a></li>
<li class="toclevel-3"><a href="#Hygiene_of_macros"><span class="tocnumber">6.1.2</span> <span class="toctext">Hygiene of macros</span></a></li>
<li class="toclevel-3"><a href="#Controlled_breaking_hygiene"><span class="tocnumber">6.1.3</span> <span class="toctext">Controlled breaking hygiene</span></a></li>
<li class="toclevel-3"><a href="#Unhygienic_variables"><span class="tocnumber">6.1.4</span> <span class="toctext">Unhygienic variables</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</td></tr></tbody></table>
<p><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
</p>
<a name="What_exactly_is_a_macro.3F"></a><h2> What exactly is a macro? </h2>
<p><br>
Basically every macro is a function, which takes a fragment
of code as parameter(s) and returns some other code. On the highest 
level of abstraction it doesn't matter if parameters are function calls, 
type definitions or just a sequence of assignments. The most important fact is 
that they are not common objects (e.g. instances of some types, like 
integer numbers), but their internal representation in the compiler (i.e. 
syntax trees).
</p><p>A macro is defined in the program just like any other function, using
common Nemerle syntax. The only difference is the structure of the data 
it operates on and the way in which it is used (executed at compile-time). 
</p><p>A macro, once created, can be used to process some parts of the code.
It's done by calling it with block(s) of code as parameter(s). 
This operation is in most cases indistinguishable from a common function
call (like <i>f(1)</i>), so a programmer using a macro would not be confused 
by unknown syntax. The main concept of our design is to make the usage of macros 
as transparent as possible. From the user point of view, it is not 
important if particular parameters are passed to a macro, 
(which would process them at the compile-time and insert some new 
code in their place), or to an ordinary function.
</p>
<a name="Defining_a_new_macro"></a><h2> Defining a new macro </h2>
<p>Writing a macro is as simple as writing a common function. It looks
the same, except that it is preceded by a keyword <tt>macro</tt> and it lives at the top level (not inside any class). 
This will make the compiler know about how to use the defined method 
(i.e. run it at the compile-time in every place where it is used). 
</p><p>Macros can take zero (if we just want to generate new code)
or more parameters. They are all elements of the language 
grammar, so their type is limited to the set of defined
syntax objects. The same holds for a return value of a macro.
</p><p>Example:
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">macro</span> generate_expression <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">{</span>
  MyModule.compute_some_expression <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>This example macro does not take any parameters and is used in the
code by simply writing <tt>generate_expression ();</tt>. 
The most important is the difference between <tt>generate_expression</tt>
and <tt>compute_some_expression</tt> - the first one is a function
executed by the compiler during compilation, while the latter is just
some common function that must return syntax tree of expressions
(which is here returned and inserted into program code by
<tt>generate_expression</tt>).
</p>
<a name="Compiling_a_simplest_macro"></a><h3> Compiling a simplest macro </h3>
<p>In order to create and use a macro you have to write a
library, which will contain its executable form. You simply 
create a new file <tt>mymacro.n</tt>, which can contain for 
example
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">macro</span> m <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(0, 0, 0);">Nemerle</span>.IO.printf <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"compile-time<span style="color: rgb(0, 128, 128); font-weight: bold;">\n</span>"</span><span style="color: rgb(0, 0, 0);">)</span>;
  &lt;<span style="color: rgb(0, 0, 0);">[</span> <span style="color: rgb(0, 0, 0);">Nemerle</span>.IO.printf <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"run-time<span style="color: rgb(0, 128, 128); font-weight: bold;">\n</span>"</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>and compile it with command
</p>
<pre>ncc -r Nemerle.Compiler.dll -t:dll mymacro.n -o mymacro.dll
</pre>
<p>Now you can use <tt>m()</tt> in any program, like here
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">module</span> M <span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> Main <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span> <span style="color: rgb(0, 0, 0);">{</span>
    m <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>You must add a reference to <tt>mymacro.dll</tt> during 
compilation of this program. It might look like
</p>
<pre>ncc -r mymacro.dll myprog.n -o myprog.exe
</pre>
<a name="Exercise"></a><h3> Exercise </h3>
<p>Write a macro, which, when used, should slow down the compilation by 5 seconds
(use <tt>System.Timers</tt> namespace) and print the version of the operating
system used to compile program (use <tt>System.Environment</tt> namespace).
</p>
<a name="Operating_on_syntax_trees"></a><h2> Operating on syntax trees </h2>
<p>Definition of function <tt>compute_some_expression</tt> might look
like:
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">using</span> <span style="color: rgb(0, 0, 0);">Nemerle</span>.Compiler.Parsetree;
&nbsp;
<span style="color: rgb(6, 0, 255);">module</span> MyModule 
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">mutable</span> debug_on&nbsp;: <span style="color: rgb(255, 0, 0);">bool</span>;
&nbsp;
  <span style="color: rgb(6, 0, 255);">public</span> compute_some_expression <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: PExpr 
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>debug_on<span style="color: rgb(0, 0, 0);">)</span> 
      &lt;<span style="color: rgb(0, 0, 0);">[</span> <span style="color: rgb(0, 0, 0);">System</span>.Console.WriteLine <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"Hello, I'm debug message"</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;
    <span style="color: rgb(6, 0, 255);">else</span>
      &lt;<span style="color: rgb(0, 0, 0);">[</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>The examples above show a macro, which conditionally inlines expression
printing a message. It's not quite useful yet, but it has introduced the
meaning of compile-time computations and also some new syntax used only 
in writing macros and functions operating on syntax trees.
We have written here the <tt>&lt;[ ... ]&gt;</tt> constructor to
build a syntax tree of expression (e.g. '<tt>()</tt>').
</p>
<a name="Quotation_operator"></a><h3> Quotation operator </h3>
<p><tt>&lt;[ ... ]&gt;</tt> is used to both construction and 
decomposition of syntax trees. Those operations are similar to
quotation of code. Simply, everything which is written inside 
<tt>&lt;[ ... ]&gt;</tt>, corresponds to its own syntax tree. 
It can be any valid Nemerle code, so a programmer does not have to 
learn internal representation of syntax trees in the compiler.
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">macro</span> print_date <span style="color: rgb(0, 0, 0);">(</span>at_compile_time<span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">{</span>                   
  <span style="color: rgb(6, 0, 255);">match</span> <span style="color: rgb(0, 0, 0);">(</span>at_compile_time<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
    | &lt;<span style="color: rgb(0, 0, 0);">[</span> <span style="color: rgb(6, 0, 255);">true</span> <span style="color: rgb(0, 0, 0);">]</span>&gt; =&gt; MyModule.print_compilation_time <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
    | _ =&gt; &lt;<span style="color: rgb(0, 0, 0);">[</span> WriteLine <span style="color: rgb(0, 0, 0);">(</span>DateTime.Now.ToString <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>The quotation alone allows using only constant expressions, which
is insufficient for most tasks. For example, to write function
<tt>print_compilation_time</tt> we must be able to create an expression
based on a value known at the compile-time. In next sections we introduce
the rest of macros' syntax to operate on general syntax trees.
</p>
<a name="Matching_subexpressions"></a><h3> Matching subexpressions </h3>
<p>When we want to decompose some large code (or more precisely, 
its syntax tree), we must bind its smaller parts to variables.
Then we can process them recursively or just use them in an
arbitrary way to construct the result.
</p><p>We can operate on entire subexpressions by writing 
<tt>$( ... )</tt> or <tt>$ID</tt> inside the quotation operator 
<tt>&lt;[ ... ]&gt;</tt>. This means binding the value of 
<tt>ID</tt> or the interior of parenthesized expression to the part of 
syntax tree described by corresponding quotation.
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">macro</span> <span style="color: rgb(6, 0, 255);">for</span> <span style="color: rgb(0, 0, 0);">(</span>init, cond, change, body<span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">{</span>
  &lt;<span style="color: rgb(0, 0, 0);">[</span> 
    $init;
    <span style="color: rgb(6, 0, 255);">def</span> loop <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span> <span style="color: rgb(0, 0, 0);">{</span>
      <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>$cond<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span> $body; $change; loop<span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">}</span> 
      <span style="color: rgb(6, 0, 255);">else</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
    <span style="color: rgb(0, 0, 0);">}</span>;
    loop <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">]</span>&gt;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>The above macro defines function <tt>for</tt>, which is
similar to the loop known from C. It can be used like this
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">for</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(6, 0, 255);">mutable</span> i = <span style="color: rgb(255, 0, 0);">0</span>, i &lt; <span style="color: rgb(255, 0, 0);">10</span>, i++, printf <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"%d"</span>, i<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span></pre>
<p>Later we show how to extend the language syntax to make the syntax
of <tt>for</tt> exactly as in C.
</p>
<a name="Base_elements_of_grammar"></a><h3> Base elements of grammar </h3>
<p>Sometimes quoted expressions have literals inside of them
(like strings, integers, etc.) and we want to operate on
their value, not on their syntax trees. It is possible, 
because they are constant expressions and their runtime
value is known at the compile-time. 
</p><p>Let's consider the previously used function <tt>print_compilation_time</tt>. 
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">using</span> <span style="color: rgb(0, 0, 0);">System</span>;
<span style="color: rgb(6, 0, 255);">using</span> <span style="color: rgb(0, 0, 0);">Nemerle</span>.Compiler.Parsetree;
&nbsp;
<span style="color: rgb(6, 0, 255);">module</span> MyModule <span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> print_compilation_time <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: PExpr
  <span style="color: rgb(0, 0, 0);">{</span>                   
    &lt;<span style="color: rgb(0, 0, 0);">[</span> <span style="color: rgb(0, 0, 0);">System</span>.Console.WriteLine <span style="color: rgb(0, 0, 0);">(</span>$<span style="color: rgb(0, 0, 0);">(</span>DateTime.Now.ToString <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">string</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>Here we see some new extension of splicing syntax where we 
create a syntax tree of string literal from a known value.
It is done by adding <tt>: string</tt> inside the
<tt>$(...)</tt> construct. One can think about it as of
enforcing the type of spliced expression to a literal (similar
to common Nemerle type enforcement), but in the matter
of fact something more is happening here - a real value
is lifted to its representation as syntax tree of a literal.
</p><p>Other types of literals (<tt>int</tt>, <tt>bool</tt>, <tt>float</tt>, 
<tt>char</tt>) are treated the same.  
This notation can be used also in pattern matching. We can
match constant values in expressions this way.
</p><p>There is also a similar schema for splicing and matching 
variables of a given name. <tt>$(v&nbsp;: name)</tt> denotes a
variable, whose name is contained by object <tt>v</tt> 
(of special type <tt>Name</tt>). There are some good 
<a href="#chunk-Macros" title="Macros">reasons</a> for encapsulating a real identifier
within this object. 
</p>
<a name="Constructs_with_variable_amount_of_elements"></a><h3> Constructs with variable amount of elements </h3>
<p>You might have noticed, that Nemerle has a few grammar elements, 
which are composed of a list of subexpressions. For example, a sequence
of expressions enclosed with <tt>{</tt> .. <tt>}</tt> braces may
contain zero or more elements. 
</p><p>When splicing values of some expressions, we would like to decompose
or compose such constructs in a general way - i.e. obtain all expressions
in a given sequence. It is natural to think about them as if a list of 
expressions and to bind this list to some variable in meta-language. 
It is done with special syntax <tt>..</tt>:
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">mutable</span> exps = <span style="color: rgb(0, 0, 0);">[</span> &lt;<span style="color: rgb(0, 0, 0);">[</span> printf <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"%d "</span>, x<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;, &lt;<span style="color: rgb(0, 0, 0);">[</span> printf <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"%d "</span>, y<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">]</span>&gt; <span style="color: rgb(0, 0, 0);">]</span>;
exps = &lt;<span style="color: rgb(0, 0, 0);">[</span> <span style="color: rgb(6, 0, 255);">def</span> x = <span style="color: rgb(255, 0, 0);">1</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;&nbsp;:: &lt;<span style="color: rgb(0, 0, 0);">[</span> <span style="color: rgb(6, 0, 255);">def</span> y = <span style="color: rgb(255, 0, 0);">2</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;&nbsp;:: exps;
&lt;<span style="color: rgb(0, 0, 0);">[</span> <span style="color: rgb(0, 0, 0);">{</span>.. $exps <span style="color: rgb(0, 0, 0);">}</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;</pre>
<p>We have used <tt>{ .. $exps }</tt> here to create the sequence of 
expressions from list <tt>exps&nbsp;: list&lt;Expr&gt;;</tt>. 
A similar syntax is used to splice the content of tuples (<tt>( .. $elist )</tt>) 
and other constructs, like <tt>array []</tt>:
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">using</span> <span style="color: rgb(0, 0, 0);">Nemerle</span>.Collections;
&nbsp;
<span style="color: rgb(6, 0, 255);">macro</span> castedarray <span style="color: rgb(0, 0, 0);">(</span>e<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
 <span style="color: rgb(6, 0, 255);">match</span> <span style="color: rgb(0, 0, 0);">(</span>e<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
  | &lt;<span style="color: rgb(0, 0, 0);">[</span> <span style="color: rgb(6, 0, 255);">array</span> <span style="color: rgb(0, 0, 0);">[</span>.. $elements <span style="color: rgb(0, 0, 0);">]</span> <span style="color: rgb(0, 0, 0);">]</span>&gt; =&gt;
     <span style="color: rgb(6, 0, 255);">def</span> casted = List.Map <span style="color: rgb(0, 0, 0);">(</span>elements, <span style="color: rgb(6, 0, 255);">fun</span> <span style="color: rgb(0, 0, 0);">(</span>x<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span> &lt;<span style="color: rgb(0, 0, 0);">[</span> <span style="color: rgb(0, 0, 0);">(</span>$x&nbsp;: <span style="color: rgb(255, 0, 0);">object</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">]</span>&gt; <span style="color: rgb(0, 0, 0);">}</span><span style="color: rgb(0, 0, 0);">)</span>;
     &lt;<span style="color: rgb(0, 0, 0);">[</span> <span style="color: rgb(6, 0, 255);">array</span> <span style="color: rgb(0, 0, 0);">[</span>.. $casted<span style="color: rgb(0, 0, 0);">]</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;
  | _ =&gt; e
 <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>If the exact number of expressions in tuple/sequence is known during
writing the quotation, then it can be expressed with
</p>
<pre class="nemerle">&lt;<span style="color: rgb(0, 0, 0);">[</span> $e_<span style="color: rgb(255, 0, 0);">1</span>; $e_<span style="color: rgb(255, 0, 0);">2</span>; $e_<span style="color: rgb(255, 0, 0);">3</span>; x = <span style="color: rgb(255, 0, 0);">2</span>; f <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;</pre>
<p>The <tt>..</tt> syntax is used when there are <tt>e_i&nbsp;: Expr</tt> for
<tt>1 &lt;= i &lt;= n</tt>.
</p>
<a name="Exercise_2"></a><h3> Exercise </h3>
<p>Write a macro <tt>rotate</tt>, which takes two parameters: a pair of
floating point numbers (describing a point in 2D space) and an angle (in 
radians). The macro should return a new pair -- a point rotated by the given 
angle. The macro should use as much information as is available at the 
compile-time, e.g. if all numbers supplied are constant, then only the final 
result should be inlined, otherwise the result must be computed at runtime.
</p>
<a name="Adding_new_syntax_to_the_compiler"></a><h2> Adding new syntax to the compiler </h2>
<p>After we have written the <tt>for</tt> macro, we would like the compiler
to understand some changes to its syntax. Especially the C-like notation
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">for</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(6, 0, 255);">mutable</span> i = <span style="color: rgb(255, 0, 0);">0</span>; i &lt; n; --i<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
  sum += i;
  <span style="color: rgb(0, 0, 0);">Nemerle</span>.IO.printf <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"%d<span style="color: rgb(0, 128, 128); font-weight: bold;">\n</span>"</span>, sum<span style="color: rgb(0, 0, 0);">)</span>;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>In order to achieve that, we have to define which tokens and grammar
elements may form a call of <tt>for</tt> macro. We do that by changing
its header to
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">macro</span> <span style="color: rgb(6, 0, 255);">for</span> <span style="color: rgb(0, 0, 0);">(</span>init, cond, change, body<span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(6, 0, 255);">syntax</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"for"</span>, <span style="color: rgb(128, 128, 128);">"("</span>, init, <span style="color: rgb(128, 128, 128);">";"</span>, cond, <span style="color: rgb(128, 128, 128);">";"</span>, change, <span style="color: rgb(128, 128, 128);">")"</span>, body<span style="color: rgb(0, 0, 0);">)</span></pre>
<p>The <tt>syntax</tt> keyword is used here to define a list of elements forming
the syntax of the macro call. The first token must always be an unique identifier
(from now on it is treated as a special keyword triggering parsing of
defined sequence). It is followed by tokens composed of operators or
identifiers passed as string literals or names of parameters of macro.
Each parameter must occur exactly once.
</p><p>Parsing of syntax rule is straightforward - tokens from input
program must match those from definition, parameters are parsed
according to their type. Default type of a parameter is 
<tt>Expr</tt>, which is just an ordinary expression (consult Nemerle
grammar in <a href="http://wiki.nemerle.org/Reference" title="Reference">Reference</a>). All allowed parameter types 
will be described in the extended version of reference manual corresponding
to macros.
</p>
<a name="Exercise_3"></a><h3> Exercise </h3>
<p>Add a new syntactic construct <tt>forpermutation</tt> to your program.
It should be defined as the macro
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">macro</span> forp <span style="color: rgb(0, 0, 0);">(</span>i, n&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>, m&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>, body<span style="color: rgb(0, 0, 0);">)</span></pre>
<p>and introduce syntax, which allows writing the following program
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">mutable</span> i = <span style="color: rgb(255, 0, 0);">0</span>;
forpermutation <span style="color: rgb(0, 0, 0);">(</span>i <span style="color: rgb(6, 0, 255);">in</span> <span style="color: rgb(255, 0, 0);">3</span> to <span style="color: rgb(255, 0, 0);">10</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">Nemerle</span>.IO.printf <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"%d<span style="color: rgb(0, 128, 128); font-weight: bold;">\n</span>"</span>, i<span style="color: rgb(0, 0, 0);">)</span></pre>
<p>It should create a random permutation <tt>p</tt> of numbers 
<tt>x_j, m &lt;= x_j &lt;= n</tt> at the compile-time. 
Then generate the code executing body of the loop 
<tt>n - m + 1</tt> times, preceding each of them with assignment of 
permutation element to <tt>i</tt>.
</p>
<a name="Macros_in_custom_attributes"></a><h2> Macros in custom attributes </h2>
<a name="Executing_macros_on_type_declarations"></a><h3> Executing macros on type declarations </h3>
<p>Nemerle macros are simply plugins to the compiler. We decided
not to restrict them only to operations on expressions, but
allow them to transform almost any part of program. 
</p><p>Macros can be used within custom attributes written near methods, 
type declarations, method parameters, fields, etc. They are
executed with those entities passed as their parameters.
</p><p><br>
As an example, let us take a look at <tt>Serializable</tt> macro.
Its usage looks like this:
</p>
<pre class="nemerle"><span style="color: rgb(0, 0, 0);">[</span>Serializable<span style="color: rgb(0, 0, 0);">]</span>
<span style="color: rgb(255, 0, 0);">class</span> S <span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">this</span> <span style="color: rgb(0, 0, 0);">(</span>v&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>, m&nbsp;: S<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span> a = v; my = m; <span style="color: rgb(0, 0, 0);">}</span>
  my&nbsp;: S;
  a&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>From now on, <tt>S</tt> has additional method <tt>Serialize</tt>
and it implements interface <tt>ISerializable</tt>. We can use
it in our code like this
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">def</span> s = S <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">4</span>, S <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">5</span>, <span style="color: rgb(6, 0, 255);">null</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>;
s.Serialize <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;</pre>
<p>And the output is
</p>
<pre class="xml"><span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;a<span style="font-weight: bold; color: black;">&gt;</span></span></span>4<span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;/a<span style="font-weight: bold; color: black;">&gt;</span></span></span>
<span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;my<span style="font-weight: bold; color: black;">&gt;</span></span></span>
  <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;a<span style="font-weight: bold; color: black;">&gt;</span></span></span>5<span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;/a<span style="font-weight: bold; color: black;">&gt;</span></span></span>
  <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;my<span style="font-weight: bold; color: black;">&gt;</span></span></span>
    <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;null</span><span style="font-weight: bold; color: black;">/&gt;</span></span>
  <span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;/my<span style="font-weight: bold; color: black;">&gt;</span></span></span>
<span style="color: rgb(0, 153, 0);"><span style="font-weight: bold; color: black;">&lt;/my<span style="font-weight: bold; color: black;">&gt;</span></span></span></pre>
<p>The macro modifies type S at compile-time and adds some code to it. 
Also inheritance relation of given class is changed, by making it 
implement interface ISerializable
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(255, 0, 0);">interface</span> ISerializable <span style="color: rgb(0, 0, 0);">{</span>
  Serialize <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<a name="Manipulating_type_declarations"></a><h3> Manipulating type declarations </h3>
<p>In general, macros placed in attributes can do many transformations 
and analysis of program objects passed to them. To see 
<tt>Serializable</tt> macro's internals and discuss some design 
issues, let's go into its code.
</p>
<pre class="nemerle"><span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(0, 0, 0);">Nemerle</span>.MacroUsage <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">Nemerle</span>.MacroPhase.BeforeInheritance, <span style="color: rgb(0, 0, 0);">Nemerle</span>.MacroTargets.<span style="color: rgb(255, 0, 0);">Class</span>,
                     Inherited = <span style="color: rgb(6, 0, 255);">true</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">]</span>
<span style="color: rgb(6, 0, 255);">macro</span> Serializable <span style="color: rgb(0, 0, 0);">(</span>t&nbsp;: TypeBuilder<span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">{</span>
  t.AddImplementedInterface <span style="color: rgb(0, 0, 0);">(</span>&lt;<span style="color: rgb(0, 0, 0);">[</span> ISerializable <span style="color: rgb(0, 0, 0);">]</span>&gt;<span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>First we have to add interface, which given type is about to
implement. But more important thing is the phase modifier 
<tt>BeforeInheritance</tt> in macro's custom attribute. In general, 
we separate three <a href="#chunk-Macros_tutorial" title="Macros tutorial">stages of execution</a> for attribute macros.
<tt>BeforeInheritance</tt> specifies that the macro will be able to change 
subtyping information of the class it operates on.
</p><p>So, we have added interface to our type, we now have to create 
Serialize () method.
</p>
<pre class="nemerle"><span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(0, 0, 0);">Nemerle</span>.MacroUsage <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">Nemerle</span>.MacroPhase.WithTypedMembers, <span style="color: rgb(0, 0, 0);">Nemerle</span>.MacroTargets.<span style="color: rgb(255, 0, 0);">Class</span>,
                     Inherited = <span style="color: rgb(6, 0, 255);">true</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">]</span>
<span style="color: rgb(6, 0, 255);">macro</span> Serializable <span style="color: rgb(0, 0, 0);">(</span>t&nbsp;: TypeBuilder<span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(0, 128, 128); font-style: italic;">/// here we list its fields and choose only those, which are not derived</span>
  <span style="color: rgb(0, 128, 128); font-style: italic;">/// or static</span>
  <span style="color: rgb(6, 0, 255);">def</span> fields = t.GetFields <span style="color: rgb(0, 0, 0);">(</span>BindingFlags.Instance | BindingFlags.<span style="color: rgb(6, 0, 255);">Public</span> %|
                            BindingFlags.NonPublic | BindingFlags.DeclaredOnly<span style="color: rgb(0, 0, 0);">)</span>;
&nbsp;
  <span style="color: rgb(0, 128, 128); font-style: italic;">/// now create list of expressions which will print object's data  </span>
  <span style="color: rgb(6, 0, 255);">mutable</span> serializers = <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(0, 0, 0);">]</span>;
&nbsp;
  <span style="color: rgb(0, 128, 128); font-style: italic;">/// traverse through fields, taking their type constructors  </span>
  <span style="color: rgb(6, 0, 255);">foreach</span> <span style="color: rgb(0, 0, 0);">(</span>x&nbsp;: IField <span style="color: rgb(6, 0, 255);">in</span> fields<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">def</span> tc = x.GetMemType <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>.TypeInfo;
    <span style="color: rgb(6, 0, 255);">def</span> nm = Macros.UseSiteSymbol <span style="color: rgb(0, 0, 0);">(</span>x.Name<span style="color: rgb(0, 0, 0);">)</span>;
    <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>tc&nbsp;!= <span style="color: rgb(6, 0, 255);">null</span><span style="color: rgb(0, 0, 0);">)</span>
      <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>tc.IsValueType<span style="color: rgb(0, 0, 0);">)</span>
        <span style="color: rgb(0, 128, 128); font-style: italic;">/// we can safely print value types as strings        </span>
        serializers = &lt;<span style="color: rgb(0, 0, 0);">[</span>
                         printf <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"&lt;%s&gt;"</span>, $<span style="color: rgb(0, 0, 0);">(</span>x.Name&nbsp;: <span style="color: rgb(255, 0, 0);">string</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>;
                         <span style="color: rgb(0, 0, 0);">System</span>.Console.Write <span style="color: rgb(0, 0, 0);">(</span>$<span style="color: rgb(0, 0, 0);">(</span>nm&nbsp;: name<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>;
                         printf <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"&lt;/%s&gt;<span style="color: rgb(0, 128, 128); font-weight: bold;">\n</span>"</span>, $<span style="color: rgb(0, 0, 0);">(</span>x.Name&nbsp;: <span style="color: rgb(255, 0, 0);">string</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>;
                       <span style="color: rgb(0, 0, 0);">]</span>&gt;
                      &nbsp;:: serializers
      <span style="color: rgb(6, 0, 255);">else</span>
        <span style="color: rgb(0, 128, 128); font-style: italic;">/// we can try to check, if type of given field also implements ISerializable</span>
        <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>x.GetMemType <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>.Require <span style="color: rgb(0, 0, 0);">(</span>&lt;<span style="color: rgb(0, 0, 0);">[</span> ttype: ISerializable <span style="color: rgb(0, 0, 0);">]</span>&gt;<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
          serializers = &lt;<span style="color: rgb(0, 0, 0);">[</span>
                           printf <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"&lt;%s&gt;<span style="color: rgb(0, 128, 128); font-weight: bold;">\n</span>"</span>, $<span style="color: rgb(0, 0, 0);">(</span>x.Name&nbsp;: <span style="color: rgb(255, 0, 0);">string</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>;      
                           <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>$<span style="color: rgb(0, 0, 0);">(</span>nm&nbsp;: name<span style="color: rgb(0, 0, 0);">)</span>&nbsp;!= <span style="color: rgb(6, 0, 255);">null</span><span style="color: rgb(0, 0, 0);">)</span>
                             $<span style="color: rgb(0, 0, 0);">(</span>nm&nbsp;: name<span style="color: rgb(0, 0, 0);">)</span>.Serialize <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
                           <span style="color: rgb(6, 0, 255);">else</span>
                             printf <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"&lt;null/&gt;<span style="color: rgb(0, 128, 128); font-weight: bold;">\n</span>"</span><span style="color: rgb(0, 0, 0);">)</span>;
                           printf <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"&lt;/%s&gt;<span style="color: rgb(0, 128, 128); font-weight: bold;">\n</span>"</span>, $<span style="color: rgb(0, 0, 0);">(</span>x.Name&nbsp;: <span style="color: rgb(255, 0, 0);">string</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>;
                         <span style="color: rgb(0, 0, 0);">]</span>&gt;
                        &nbsp;:: serializers
        <span style="color: rgb(6, 0, 255);">else</span>
          <span style="color: rgb(0, 128, 128); font-style: italic;">/// and finally, we encounter case when there is no easy way to serialize </span>
          <span style="color: rgb(0, 128, 128); font-style: italic;">/// given field</span>
          Message.FatalError <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"field `"</span> + x.Name + <span style="color: rgb(128, 128, 128);">"' cannot be serialized"</span><span style="color: rgb(0, 0, 0);">)</span>
    <span style="color: rgb(6, 0, 255);">else</span>
      Message.FatalError <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"field `"</span> + x.Name + <span style="color: rgb(128, 128, 128);">"' cannot be serialized"</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">}</span>;
  <span style="color: rgb(0, 128, 128); font-style: italic;">// after analyzing fields, we create method in our type, to execute created</span>
  <span style="color: rgb(0, 128, 128); font-style: italic;">// expressions</span>
  t.Define <span style="color: rgb(0, 0, 0);">(</span>&lt;<span style="color: rgb(0, 0, 0);">[</span> decl: <span style="color: rgb(6, 0, 255);">public</span> Serialize <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
                     implements ISerializable.Serialize <span style="color: rgb(0, 0, 0);">{</span>
                       .. $serializers
                     <span style="color: rgb(0, 0, 0);">}</span>
            <span style="color: rgb(0, 0, 0);">]</span>&gt;<span style="color: rgb(0, 0, 0);">)</span>;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p><br>
</p>
<a name="Execution_stages"></a><h3> Execution stages </h3>
<p>Analysing object-oriented hierarchy and class members is a separate pass of the compilation. 
First it creates inheritance relation between classes, so we know exactly all base types of
given type. After that every member inside of them (methods, fields, etc.)
is being analysed and added to the hierarchy and its type annotations are resolved. 
After that also the rules regarding implemented interface methods are checked.
</p><p>For the needs of macros we have decided to distinguish three moments in
this pass at which they can operate on elements of class hierarchy.
Every macro can be annotated with a stage, at which it should be executed.
</p>
<ul><li><b>BeforeInheritance</b> stage is performed after parsing whole
program and scanning declared types, but before building subtyping
relation between them. It gives macro a freedom to change inheritance
hierarchy and operate on parse-tree of classes and members
</li><li><b>BeforeTypedMembers</b> is when inheritance of types is
already set. Macros can still operate on bare parse-trees, but utilize
information about subtyping.
</li><li><b>WithTypedMembers</b> stage is after headers of methods,
fields are already analysed and in bound state. Macros can easily
traverse entire class space by reflecting type constructors of fields,
method parameters, etc. Original parse-trees are no longer available
and signatures of class members cannot be changed.
</li></ul>
<a name="Parameters_of_attribute_macros"></a><h4> Parameters of attribute macros </h4>
<p>Every executed attribute macro operates on some element of class hierarchy, 
so it must be supplied with an additional parameter describing the object, on which macro was placed. 
This way it can easily query for properties of that element and use compiler's API to reflect or change the
context in which it was defined. 
</p><p>For example a method macro declaration would be
</p>
<pre class="nemerle"><span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(0, 0, 0);">Nemerle</span>.MacroUsage <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">Nemerle</span>.MacroPhase.WithTypedMembers,
                     <span style="color: rgb(0, 0, 0);">Nemerle</span>.MacroTargets.Method<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">]</span>
<span style="color: rgb(6, 0, 255);">macro</span> MethodMacro <span style="color: rgb(0, 0, 0);">(</span>t&nbsp;: TypeBuilder, f&nbsp;: MethodBuilder, expr<span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(0, 128, 128); font-style: italic;">// use 't' and 'f' to query or change class-level elements</span>
  <span style="color: rgb(0, 128, 128); font-style: italic;">// of program</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>Macro is annotated with additional attributes specifying respectively the
stage in which macro will be executed and the macro target.
</p><p>The available parameters contain references to class hierarchy elements that given macro operates on. 
They are automatically supplied by compiler and they vary on the target and stage of given macro.
Here is a little table specifying valid parameters for each stage and target of attribute macro.
</p>
<table border="1" cellpadding="2">
<caption>Attribute macro targets and parameters
</caption>
<tbody><tr>
<th> MacroTarget </th><th> MacroPhase.BeforeInheritance </th><th> MacroPhase.BeforeTypedMembers </th><th> MacroPhase.WithTypedMembers
</th></tr>
<tr>
<th> Class
</th><td> TypeBuilder </td><td> TypeBuilder </td><td> TypeBuilder
</td></tr>
<tr>
<th> Method
</th><td> TypeBuilder, ParsedMethod </td><td> TypeBuilder, ParsedMethod </td><td> TypeBuilder, MethodBuilder
</td></tr>
<tr>
<th> Field
</th><td> TypeBuilder, ParsedField </td><td> TypeBuilder, ParsedField </td><td> TypeBuilder, FieldBuilder
</td></tr>
<tr>
<th> Property
</th><td> TypeBuilder, ParsedProperty </td><td> TypeBuilder, ParsedProperty </td><td> TypeBuilder, PropertyBuilder
</td></tr>
<tr>
<th> Event
</th><td> TypeBuilder, ParsedEvent </td><td> TypeBuilder, ParsedEvent </td><td> TypeBuilder, EventBuilder
</td></tr>
<tr>
<th> Parameter
</th><td> TypeBuilder, ParsedMethod, ParsedParameter </td><td> TypeBuilder, ParsedMethod, ParsedParameter </td><td> TypeBuilder, MethodBuilder, ParameterBuilder
</td></tr>
<tr>
<th> Assembly
</th><td> (none) </td><td> (none) </td><td> (none)
</td></tr></tbody></table>
<p>The intuition is that every macro has parameter holding its target
and additionally objects containing it (like TypeBuilder is available
in most of the attribute macros).
</p><p>After those implicitly available parameters there come standard
parameters explicitly supplied by user. They are the same as for
expression level macros.
</p>
<a name="Reference_to_more_advanced_aspects"></a><h2> Reference to more advanced aspects </h2>
<a name="Hygiene_and_alpha-renaming_of_identifiers"></a><h3> Hygiene and alpha-renaming of identifiers </h3>
<a name="Problem_with_names_capture"></a><h4> Problem with names capture </h4>
<p>Identifiers in quoted code (object code) must be treated
in a special way, because we usually do not know in which
scope they would appear. Especially they should not mix
with variables with the same names from the macro-use site.
</p><p><br>
Consider the following macro defining a local function <tt>f</tt>
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">macro</span> identity <span style="color: rgb(0, 0, 0);">(</span>e<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span> &lt;<span style="color: rgb(0, 0, 0);">[</span> <span style="color: rgb(6, 0, 255);">def</span> f <span style="color: rgb(0, 0, 0);">(</span>x<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span> x <span style="color: rgb(0, 0, 0);">}</span>; f<span style="color: rgb(0, 0, 0);">(</span>$e<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">]</span>&gt; <span style="color: rgb(0, 0, 0);">}</span></pre>
<p>Calling it with <tt>identity (f(1))</tt> might generate 
confusing code like
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">def</span> f <span style="color: rgb(0, 0, 0);">(</span>x<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span> x <span style="color: rgb(0, 0, 0);">}</span>; f <span style="color: rgb(0, 0, 0);">(</span>f <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span></pre>
<p>To preserve names capture, all macro generated variables 
should be renamed to their unique counterparts, like in
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">def</span> f_<span style="color: rgb(255, 0, 0);">42</span> <span style="color: rgb(0, 0, 0);">(</span>x_<span style="color: rgb(255, 0, 0);">43</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span> x_<span style="color: rgb(255, 0, 0);">43</span> <span style="color: rgb(0, 0, 0);">}</span>; f_<span style="color: rgb(255, 0, 0);">42</span> <span style="color: rgb(0, 0, 0);">(</span>f <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span></pre>
<a name="Hygiene_of_macros"></a><h4> Hygiene of macros </h4>
<p>The idea of separating variables introduced by a macro from 
those defined in the plain code (or other macros) is called 
`hygiene' after Lisp and Scheme languages. In Nemerle 
we define it as putting identifiers created during a single 
macro execution into a unique namespace. Variables from
different namespaces cannot bind to each other.
</p><p><br>
In other words, a macro cannot create identifiers capturing
any external variables or visible outside of its own 
generated code. This means, that there is no need to care
about locally used names.
</p><p><br>
The Hygiene is obtained by encapsulating identifiers in special
<tt>Name</tt> class. The compiler uses it to distinguish names
from different macro executions and scopes (for details of
implementation consult <a href="http://nemerle.org/metaprogramming.pdf" class="external text" title="http://nemerle.org/metaprogramming.pdf">paper about macros</a>).
Variables with appropriate information are created 
automatically by quotation.
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">def</span> definition = &lt;<span style="color: rgb(0, 0, 0);">[</span> <span style="color: rgb(6, 0, 255);">def</span> y = <span style="color: rgb(255, 0, 0);">4</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;;
&lt;<span style="color: rgb(0, 0, 0);">[</span> <span style="color: rgb(6, 0, 255);">def</span> x = <span style="color: rgb(255, 0, 0);">5</span>; $definition; x + y <span style="color: rgb(0, 0, 0);">]</span>&gt;</pre>
<p>When a macro creates the above code, identifiers <tt>y</tt> and 
<tt>x</tt> are tagged with the same unique mark. Now they
cannot be captured by any external variables (with a 
different mark). We operate on the <tt>Name</tt> class, when the
quoted code is composed or decomposed and we use 
<tt>&lt;[ $(x&nbsp;: name) ]&gt;</tt> construct. Here <tt>x</tt> 
is bound to am object of type <tt>Name</tt>, which we can use
in other place to create exactly the same identifier.
</p><p>An identifier can be also created by calling method
<tt>Macros.NewSymbol()</tt>, which returns <tt>Name</tt>
with an unique identifier, tagged with a current mark.
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">def</span> x = Macros.NewSymbol <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
&lt;<span style="color: rgb(0, 0, 0);">[</span> <span style="color: rgb(6, 0, 255);">def</span> $<span style="color: rgb(0, 0, 0);">(</span>x&nbsp;: name<span style="color: rgb(0, 0, 0);">)</span> = <span style="color: rgb(255, 0, 0);">5</span>; $<span style="color: rgb(0, 0, 0);">(</span>x&nbsp;: name<span style="color: rgb(0, 0, 0);">)</span> + <span style="color: rgb(255, 0, 0);">4</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;</pre>
<a name="Controlled_breaking_hygiene"></a><h4> Controlled breaking hygiene </h4>
<p>Sometimes it is useful to generate identifiers, which
bind to variables visible in place where a macro is used. For example
one of macro's parameters is a string with some identifiers inside. If
we want to use these as real identifiers, then we need to break
automatic hygiene. It is especially useful
in embedding domain-specific languages, which reference symbols from
the original program.
</p><p>As an example consider a <tt>Nemerle.IO.sprint (string literal)</tt> macro (which have the syntax shortcut <tt>$"some text $id "</tt>).
It searches given string literal for <i>$var</i> and creates a code concatenating text before and after <i>$var</i> to the value of <tt>var.ToString ()</tt>.
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">def</span> x = <span style="color: rgb(255, 0, 0);">3</span>;
<span style="color: rgb(0, 0, 0);">System</span>.Console.WriteLine <span style="color: rgb(0, 0, 0);">(</span>$<span style="color: rgb(128, 128, 128);">"My value of x is $x and I'm happy"</span><span style="color: rgb(0, 0, 0);">)</span>;</pre>
<p>expands to
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">def</span> x = <span style="color: rgb(255, 0, 0);">3</span>;
<span style="color: rgb(0, 0, 0);">System</span>.Console.WriteLine <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">{</span> 
  <span style="color: rgb(6, 0, 255);">def</span> sb = <span style="color: rgb(0, 0, 0);">System</span>.Text.StringBuilder <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"My value of x is "</span><span style="color: rgb(0, 0, 0);">)</span>; 
  sb.Append <span style="color: rgb(0, 0, 0);">(</span>x.ToString <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>; 
  sb.Append <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">" and I'm happy"</span><span style="color: rgb(0, 0, 0);">)</span>; 
  sb.ToString <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span> 
<span style="color: rgb(0, 0, 0);">}</span><span style="color: rgb(0, 0, 0);">)</span>;</pre>
<p>Breaking of hygiene is necessary here, because we generate code (reference to <i>x</i>), which need to have the
same context as variables from invocation place of macro.
</p><p>To make given name bind to the symbols from macro usesite, we use <tt>Nemerle.Macros.UseSiteSymbol (name&nbsp;: string)&nbsp;: Name</tt> function, or
special splicing target <i>usesite</i> in quotations. Their use would be like in this simplified implementation of macro
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">macro</span> sprint <span style="color: rgb(0, 0, 0);">(</span>lit&nbsp;: <span style="color: rgb(255, 0, 0);">string</span><span style="color: rgb(0, 0, 0);">)</span> 
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">def</span> <span style="color: rgb(0, 0, 0);">(</span>prefix, symbol, suffix<span style="color: rgb(0, 0, 0);">)</span> = Helper.ExtractDollars <span style="color: rgb(0, 0, 0);">(</span>lit<span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(6, 0, 255);">def</span> varname = <span style="color: rgb(0, 0, 0);">Nemerle</span>.Macros.UseSiteSymbol <span style="color: rgb(0, 0, 0);">(</span>symbol<span style="color: rgb(0, 0, 0);">)</span>;
  &lt;<span style="color: rgb(0, 0, 0);">[</span> 
    <span style="color: rgb(6, 0, 255);">def</span> sb = <span style="color: rgb(0, 0, 0);">System</span>.Text.StringBuilder <span style="color: rgb(0, 0, 0);">(</span>$<span style="color: rgb(0, 0, 0);">(</span>prefix&nbsp;: <span style="color: rgb(255, 0, 0);">string</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>; 
    sb.Append <span style="color: rgb(0, 0, 0);">(</span>$<span style="color: rgb(0, 0, 0);">(</span>varname&nbsp;: name<span style="color: rgb(0, 0, 0);">)</span>.ToString <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>; 
    <span style="color: rgb(0, 128, 128); font-style: italic;">// or alternatively  $(symbol&nbsp;: usesite)</span>
    sb.Append <span style="color: rgb(0, 0, 0);">(</span>$<span style="color: rgb(0, 0, 0);">(</span>suffix&nbsp;: <span style="color: rgb(255, 0, 0);">string</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>; 
    sb.ToString <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span> 
  <span style="color: rgb(0, 0, 0);">]</span>&gt;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>Note that this operations is 'safe', that is it changes context of variable to the place where macro invocation was created 
(see paper for more details).
</p>
<a name="Unhygienic_variables"></a><h4> Unhygienic variables </h4>
<p>Sometimes it is useful to completely break hygiene, where programmer
only want to experiment with new ideas. From our experience, it is often
hard to reason about correct contexts for variables, especially when
writing class level macros. In this
case it is useful to be able to easily break hygine. 
</p><p>Nemerle provides it with <i>&lt;[ $("id"&nbsp;: dyn) ]&gt;</i> construct. It makes produced variable break hygiene rules and always
bind to the nearest definition with the same name.
</p>
<!-- Saved in parser cache with key wiki:pcache:idhash:988-0!1!0!0!!en!2 and timestamp 20060121083519 -->
<a name="chunk-Partial_evaluation"></a>
	  	  <h1 class="firstHeading">Partial evaluation</h1>
	    	    	    <!-- start content -->
	    <table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Partial_evaluation_through_meta-programming"><span class="tocnumber">1</span> <span class="toctext">Partial evaluation through meta-programming</span></a>
<ul>
<li class="toclevel-2"><a href="#Power_function_-_classic_example"><span class="tocnumber">1.1</span> <span class="toctext">Power function - classic example</span></a></li>
<li class="toclevel-2"><a href="#Permutation_algorithm"><span class="tocnumber">1.2</span> <span class="toctext">Permutation algorithm</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Rewriting_interpreter_into_compiler"><span class="tocnumber">2</span> <span class="toctext">Rewriting interpreter into compiler</span></a>
<ul>
<li class="toclevel-2"><a href="#Virtual_machine"><span class="tocnumber">2.1</span> <span class="toctext">Virtual machine</span></a></li>
<li class="toclevel-2"><a href="#Language"><span class="tocnumber">2.2</span> <span class="toctext">Language</span></a></li>
<li class="toclevel-2"><a href="#Interpreter"><span class="tocnumber">2.3</span> <span class="toctext">Interpreter</span></a></li>
<li class="toclevel-2"><a href="#Staged_interpreter"><span class="tocnumber">2.4</span> <span class="toctext">Staged interpreter</span></a></li>
<li class="toclevel-2"><a href="#Usage"><span class="tocnumber">2.5</span> <span class="toctext">Usage</span></a></li>
</ul>
</li>
</ul>
</td></tr></tbody></table>
<p><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
</p>
<a name="Partial_evaluation_through_meta-programming"></a><h2> Partial evaluation through meta-programming </h2>
<p>We will discuss one of the possible applications of Nemerle meta-programming system in <a href="http://en.wikipedia.org/wiki/Partial_evaluation" class="external text" title="http://en.wikipedia.org/wiki/Partial evaluation">partial evaluation</a>. This process is based on specializing given algorithm with some of its inputs, which are known statically (at compile time). 
</p><p>This is particularly useful when we have some general algorithm
for solving a problem, but most of the time we use its special case.
For example we have a procedure <i>search</i> to search for arbitrary
pattern in a string, but 98% of its uses are with "what is The Answer"
pattern. It would be nice to have the <i>search_answer</i> procedure, which would be highly optimized version of our general algorithm.
</p><p>The methodology we will use here is general and can be used for
various problems like: specializing numerical algorithms, pattern
matching, generating compilers from interpreters, efficient embedding
of domain-specific languages.
</p>
<a name="Power_function_-_classic_example"></a><h3> Power function - classic example </h3>
<p>Let us consider a general <a href="http://en.wikipedia.org/wiki/Exponentiation" class="external text" title="http://en.wikipedia.org/wiki/Exponentiation">power function</a>. One of the most efficient ways of computing it is the logarithmic <a href="http://c2.com/cgi/wiki?IntegerPowerAlgorithm" class="external text" title="http://c2.com/cgi/wiki?IntegerPowerAlgorithm">power algorithm</a>.
</p><p>Its implementation in Nemerle is presented below:
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">static</span> power <span style="color: rgb(0, 0, 0);">(</span>x&nbsp;: <span style="color: rgb(255, 0, 0);">double</span>, n&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">double</span>
 <span style="color: rgb(0, 0, 0);">{</span>
   <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>n == <span style="color: rgb(255, 0, 0);">0</span><span style="color: rgb(0, 0, 0);">)</span>
     <span style="color: rgb(255, 0, 0);">1</span>.<span style="color: rgb(255, 0, 0);">0</span>
   <span style="color: rgb(6, 0, 255);">else</span>
     <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>n % <span style="color: rgb(255, 0, 0);">2</span> == <span style="color: rgb(255, 0, 0);">0</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 128, 128); font-style: italic;">// even</span>
       Sqr <span style="color: rgb(0, 0, 0);">(</span>power <span style="color: rgb(0, 0, 0);">(</span>x, n / <span style="color: rgb(255, 0, 0);">2</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
     <span style="color: rgb(6, 0, 255);">else</span>
       x * power <span style="color: rgb(0, 0, 0);">(</span>x, n - <span style="color: rgb(255, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">)</span>
 <span style="color: rgb(0, 0, 0);">}</span></pre>
<p>where <i>Sqr</i> is a standard method defined like:
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">static</span> Sqr <span style="color: rgb(0, 0, 0);">(</span>x&nbsp;: <span style="color: rgb(255, 0, 0);">double</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">double</span> <span style="color: rgb(0, 0, 0);">{</span> x * x <span style="color: rgb(0, 0, 0);">}</span></pre>
<p>As we can see it divides <i>n</i> by 2 if it is even and decrements
by 1 if it is odd. In former case it performs square operation and in
latter multiplication by <i>x</i> parameter. Note that the pattern of those operation depends only on <i>n</i> - <i>x</i> and <i>n</i> parameters are independent. 
</p><p>Here we come to the point - when we want to have specialized power function for some <i>n</i>, then we know exactly what operations it will perform on second argument. For example optimal pattern for <i>x<sup>5</sup></i> is <i>x*(x<sup>2</sup>)<sup>2</sup></i>. Now we want compiler to be able to generate this optimal set of operations for us.
Here is the code to perform it:
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">macro</span> power1 <span style="color: rgb(0, 0, 0);">(</span>x, n&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span> 
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">def</span> pow <span style="color: rgb(0, 0, 0);">(</span>n<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>n == <span style="color: rgb(255, 0, 0);">0</span><span style="color: rgb(0, 0, 0);">)</span>
      &lt;<span style="color: rgb(0, 0, 0);">[</span> <span style="color: rgb(255, 0, 0);">1</span>.<span style="color: rgb(255, 0, 0);">0</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;
    <span style="color: rgb(6, 0, 255);">else</span>
      <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>n % <span style="color: rgb(255, 0, 0);">2</span> == <span style="color: rgb(255, 0, 0);">0</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 128, 128); font-style: italic;">// even</span>
        &lt;<span style="color: rgb(0, 0, 0);">[</span> Sqr <span style="color: rgb(0, 0, 0);">(</span>$<span style="color: rgb(0, 0, 0);">(</span>pow <span style="color: rgb(0, 0, 0);">(</span>n / <span style="color: rgb(255, 0, 0);">2</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;
      <span style="color: rgb(6, 0, 255);">else</span>
        &lt;<span style="color: rgb(0, 0, 0);">[</span> $x * $<span style="color: rgb(0, 0, 0);">(</span>pow <span style="color: rgb(0, 0, 0);">(</span>n - <span style="color: rgb(255, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;
  <span style="color: rgb(0, 0, 0);">}</span>
  pow <span style="color: rgb(0, 0, 0);">(</span>n<span style="color: rgb(0, 0, 0);">)</span>;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>We will give two different, but in general equivalent descriptions of what is happening here.
</p><p>First you can view this as <a href="http://www.cs.rice.edu/%7Etaha/MSP/" class="external text" title="http://www.cs.rice.edu/~taha/MSP/">staged computation</a>. We defere performing of <i>Sqr</i> and <i>*</i> operations until <i>x</i> is known at runtime, but we are free to perform all the others like comparisons of <i>n</i>
and recursion at earlier stage. In the result only the optimal pattern
of multiplication and square operations will be executed at runtime.
The <i>power</i> macro is just a function, which performs first stage
of computation (at compile time). The result of using this macro is
inserting the second stage operations at the place of usage. This way
the <b>&lt;[ ]&gt;</b> brackets can be considered as markers of second stage computation.
</p><p>The other way of understanding the example is by its
implementation in Nemerle compiler. It is a function generating code,
which will be substituted at the place of its usage. The <i>pow</i> function simply generates the code of arithmetic  
expression composed of multiplications and square operations. As mentioned earlier we utilize the fact, that <i>n</i> is independent from <i>x</i> and basing on it we know exactly how resulting expression should look like. Here we can view <b>&lt;[ ]&gt;</b> brackets as what they really are - syntax for constructing parts of new Nemerle code.
</p><p>The macro above can be easily used to create specialized method
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">static</span> power74 <span style="color: rgb(0, 0, 0);">(</span>x&nbsp;: <span style="color: rgb(255, 0, 0);">double</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">double</span>
<span style="color: rgb(0, 0, 0);">{</span>
  power1 <span style="color: rgb(0, 0, 0);">(</span>x, <span style="color: rgb(255, 0, 0);">74</span><span style="color: rgb(0, 0, 0);">)</span>;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>or directly in code (which would yield direct inlining of
expressions and might be not a good idea for large chunks of generated
code).
</p><p>Just a little digression. The power macro could be written as:
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">macro</span> power2 <span style="color: rgb(0, 0, 0);">(</span>x, n&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span> 
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>n == <span style="color: rgb(255, 0, 0);">0</span><span style="color: rgb(0, 0, 0);">)</span>
    &lt;<span style="color: rgb(0, 0, 0);">[</span> <span style="color: rgb(255, 0, 0);">1</span>.<span style="color: rgb(255, 0, 0);">0</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;
  <span style="color: rgb(6, 0, 255);">else</span>
    <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>n % <span style="color: rgb(255, 0, 0);">2</span> == <span style="color: rgb(255, 0, 0);">0</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 128, 128); font-style: italic;">// even</span>
      &lt;<span style="color: rgb(0, 0, 0);">[</span> Sqr <span style="color: rgb(0, 0, 0);">(</span>power2 <span style="color: rgb(0, 0, 0);">(</span>$x, $<span style="color: rgb(0, 0, 0);">(</span>n / <span style="color: rgb(255, 0, 0);">2</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;
    <span style="color: rgb(6, 0, 255);">else</span>
      &lt;<span style="color: rgb(0, 0, 0);">[</span> $x * power2 <span style="color: rgb(0, 0, 0);">(</span>$x, $<span style="color: rgb(0, 0, 0);">(</span>n - <span style="color: rgb(255, 0, 0);">1</span>&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>The resulting generated code would be identical, but here we see
usage of some different features of macro system. In single macro
execution we generate code, which contains invocation of this very
macro. Note that it is not a direct recursive call, like in previous
implementation. Although the result is the same, we encourage the
former style, as it encapsulates all the macro's computations in single
macro expansion, while the second way forces compiler to interleave
many macro expansions. The latter way is slower and infinite loops here
are harder to notice / debug.
</p>
<a name="Permutation_algorithm"></a><h3> Permutation algorithm </h3>
<p>Now we will show a little more evolved example, which shows that sometimes it is 
useful to explicitly store parts of code in collection, creating final computation from it.
</p><p>Let us consider a function for computing <a href="http://en.wikipedia.org/wiki/Permutation" class="external text" title="http://en.wikipedia.org/wiki/Permutation">permutation</a> of given array. It takes input array as first parameter and array specifying the permutation as second parameter:
</p>
<pre class="nemerle">permute <span style="color: rgb(0, 0, 0);">(</span>data&nbsp;: <span style="color: rgb(6, 0, 255);">array</span> <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">]</span>, permutation&nbsp;: <span style="color: rgb(6, 0, 255);">array</span> <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span> <span style="color: rgb(0, 0, 0);">{</span> ... <span style="color: rgb(0, 0, 0);">}</span></pre>
<p>where <i>permutation</i> array describes permutation as positions at which elements 
of input should appear in output (like for <b>3, 2, 1</b> and permutation <b>2, 1, 3</b>, the output will be <b>2, 3, 1</b>).
The algorithm utilizes the fact that this representation directly
exposes cycles of permutation and to permute elements we must simply
move them by one position on its cycle. It is presented below:
</p>
<pre class="nemerle">permute <span style="color: rgb(0, 0, 0);">(</span>data&nbsp;: <span style="color: rgb(6, 0, 255);">array</span> <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">]</span>, permutation&nbsp;: <span style="color: rgb(6, 0, 255);">array</span> <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">def</span> visited = <span style="color: rgb(6, 0, 255);">array</span> <span style="color: rgb(0, 0, 0);">(</span>permutation.Length<span style="color: rgb(0, 0, 0);">)</span>;
&nbsp;
  <span style="color: rgb(0, 128, 128); font-style: italic;">// we visit each cycle once using this top loop</span>
  <span style="color: rgb(6, 0, 255);">for</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(6, 0, 255);">mutable</span> i = <span style="color: rgb(255, 0, 0);">0</span>; i &lt; permutation.Length; i++<span style="color: rgb(0, 0, 0);">)</span> 
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">mutable</span> pos = i;
    <span style="color: rgb(0, 128, 128); font-style: italic;">// we walk through one cycle</span>
    <span style="color: rgb(6, 0, 255);">while</span> <span style="color: rgb(0, 0, 0);">(</span>!visited <span style="color: rgb(0, 0, 0);">[</span>pos<span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span> 
    <span style="color: rgb(0, 0, 0);">{</span>
      visited <span style="color: rgb(0, 0, 0);">[</span>pos<span style="color: rgb(0, 0, 0);">]</span> = <span style="color: rgb(6, 0, 255);">true</span>;
      <span style="color: rgb(0, 128, 128); font-style: italic;">// moving its elements by one position</span>
      <span style="color: rgb(6, 0, 255);">def</span> next_pos = permutation <span style="color: rgb(0, 0, 0);">[</span>pos<span style="color: rgb(0, 0, 0);">]</span>;
      <span style="color: rgb(6, 0, 255);">unless</span> <span style="color: rgb(0, 0, 0);">(</span>visited <span style="color: rgb(0, 0, 0);">[</span>next_pos<span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
        data <span style="color: rgb(0, 0, 0);">[</span>pos<span style="color: rgb(0, 0, 0);">]</span> &lt;-&gt; data <span style="color: rgb(0, 0, 0);">[</span>next_pos<span style="color: rgb(0, 0, 0);">]</span>;
        pos = next_pos;
      <span style="color: rgb(0, 0, 0);">}</span>
    <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>As we can see this algorithm does some operations of <i>data</i> only in one line
</p>
<pre class="nemerle">data <span style="color: rgb(0, 0, 0);">[</span>pos<span style="color: rgb(0, 0, 0);">]</span> &lt;-&gt; data <span style="color: rgb(0, 0, 0);">[</span>next_pos<span style="color: rgb(0, 0, 0);">]</span></pre>
<p>which is the swap operation on elements of array. The rest of its steps are performed only basing on contents of <i>permutation</i>. This quickly leads us to conclusion, that if we statically know this array, we can have highly optimized version of <i>permute</i>, which performs only sequence of swaps.
</p><p>This is exactly what partial evaluation does, removing overhead
of computations dependant only on static parameters. How do we code it
using macros in Nemerle? It is almost as simple as deffering <i>&lt;-&gt;</i> operation with <b>&lt;[ ]&gt;</b>, but two more technical issues must be addressed. 
</p><p>First we must obtain the value of permutation array inside our
first stage function (a macro). The simplest way would be to store it
in some static field visible to the macro, but we chose to pass it
directly as its parameter. Second one is that original <i>permute</i> function uses imperative
style, so we must deffer computation also in this style, explicitly
building sequence of final computations.
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">macro</span> permute1 <span style="color: rgb(0, 0, 0);">(</span>data, p_expr<span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">def</span> permutation = expr_to_array <span style="color: rgb(0, 0, 0);">(</span>p_expr<span style="color: rgb(0, 0, 0);">)</span>; <span style="color: rgb(0, 128, 128); font-style: italic;">// new</span>
&nbsp;
  <span style="color: rgb(6, 0, 255);">def</span> visited = <span style="color: rgb(6, 0, 255);">array</span> <span style="color: rgb(0, 0, 0);">(</span>permutation.Length<span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(6, 0, 255);">mutable</span> result = <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(0, 0, 0);">]</span>;                      <span style="color: rgb(0, 128, 128); font-style: italic;">// new</span>
&nbsp;
  <span style="color: rgb(6, 0, 255);">for</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(6, 0, 255);">mutable</span> i = <span style="color: rgb(255, 0, 0);">0</span>; i &lt; permutation.Length; i++<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">mutable</span> pos = i;
    <span style="color: rgb(6, 0, 255);">while</span> <span style="color: rgb(0, 0, 0);">(</span>!visited <span style="color: rgb(0, 0, 0);">[</span>pos<span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
      visited <span style="color: rgb(0, 0, 0);">[</span>pos<span style="color: rgb(0, 0, 0);">]</span> = <span style="color: rgb(6, 0, 255);">true</span>;
      <span style="color: rgb(6, 0, 255);">def</span> next_pos = permutation <span style="color: rgb(0, 0, 0);">[</span>pos<span style="color: rgb(0, 0, 0);">]</span>;
      <span style="color: rgb(6, 0, 255);">unless</span> <span style="color: rgb(0, 0, 0);">(</span>visited <span style="color: rgb(0, 0, 0);">[</span>next_pos<span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
        result = &lt;<span style="color: rgb(0, 0, 0);">[</span> 
          $data <span style="color: rgb(0, 0, 0);">[</span>$<span style="color: rgb(0, 0, 0);">(</span>pos&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">]</span> &lt;-&gt; $data <span style="color: rgb(0, 0, 0);">[</span>$<span style="color: rgb(0, 0, 0);">(</span>next_pos&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">]</span> 
        <span style="color: rgb(0, 0, 0);">]</span>&gt;&nbsp;:: result;                       <span style="color: rgb(0, 128, 128); font-style: italic;">// new</span>
         pos = next_pos;
      <span style="color: rgb(0, 0, 0);">}</span>
    <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(0, 0, 0);">}</span>
  &lt;<span style="color: rgb(0, 0, 0);">[</span> <span style="color: rgb(0, 0, 0);">{</span>..$result <span style="color: rgb(0, 0, 0);">}</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;                        <span style="color: rgb(0, 128, 128); font-style: italic;">// new</span>
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
<span style="color: rgb(0, 128, 128); font-style: italic;">// technical function used to decompose expression</span>
<span style="color: rgb(0, 128, 128); font-style: italic;">// holding contant array of ints</span>
expr_to_array <span style="color: rgb(0, 0, 0);">(</span>expr&nbsp;: PExpr<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">array</span> <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">]</span> 
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(0, 128, 128); font-style: italic;">// we must convert syntax tree of array into array itself</span>
  | &lt;<span style="color: rgb(0, 0, 0);">[</span> <span style="color: rgb(6, 0, 255);">array</span> <span style="color: rgb(0, 0, 0);">[</span>..$p_list<span style="color: rgb(0, 0, 0);">]</span> <span style="color: rgb(0, 0, 0);">]</span>&gt; =&gt;
    <span style="color: rgb(6, 0, 255);">def</span> permutation = <span style="color: rgb(6, 0, 255);">array</span> <span style="color: rgb(0, 0, 0);">(</span>p_list.Length<span style="color: rgb(0, 0, 0);">)</span>;
    <span style="color: rgb(6, 0, 255);">mutable</span> count = <span style="color: rgb(255, 0, 0);">0</span>;
    <span style="color: rgb(6, 0, 255);">foreach</span> <span style="color: rgb(0, 0, 0);">(</span>&lt;<span style="color: rgb(0, 0, 0);">[</span> $<span style="color: rgb(0, 0, 0);">(</span>x&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">]</span>&gt; <span style="color: rgb(6, 0, 255);">in</span> p_list<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
      permutation <span style="color: rgb(0, 0, 0);">[</span>count<span style="color: rgb(0, 0, 0);">]</span> = x;
      count++;
    <span style="color: rgb(0, 0, 0);">}</span>
    permutation
&nbsp;
  | _ =&gt; <span style="color: rgb(6, 0, 255);">throw</span> <span style="color: rgb(0, 0, 0);">System</span>.ArgumentException <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"only constant arrays are allowed"</span><span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>As we can see the function didn't change much. We must have added the variable <i>result</i>, which is the list of resulting expressions to execute. It is used at 
the end in <i>&lt;[ {.. $result } ]&gt;</i> expression - the sequence of swaps on <i>data</i> is the result of macro.
</p><p><i>permute</i> and <i>permute'</i> can be used as follows:
</p>
<pre class="nemerle">permute_specialized <span style="color: rgb(0, 0, 0);">(</span>data&nbsp;: <span style="color: rgb(6, 0, 255);">array</span> <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
<span style="color: rgb(0, 0, 0);">{</span>
  permute1 <span style="color: rgb(0, 0, 0);">(</span>data, <span style="color: rgb(6, 0, 255);">array</span> <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">10</span>, <span style="color: rgb(255, 0, 0);">7</span>, <span style="color: rgb(255, 0, 0);">11</span>, <span style="color: rgb(255, 0, 0);">0</span>, <span style="color: rgb(255, 0, 0);">12</span>, <span style="color: rgb(255, 0, 0);">5</span>, <span style="color: rgb(255, 0, 0);">14</span>, <span style="color: rgb(255, 0, 0);">6</span>, <span style="color: rgb(255, 0, 0);">9</span>, <span style="color: rgb(255, 0, 0);">4</span>, <span style="color: rgb(255, 0, 0);">13</span>, <span style="color: rgb(255, 0, 0);">2</span>, <span style="color: rgb(255, 0, 0);">1</span>, <span style="color: rgb(255, 0, 0);">8</span>, <span style="color: rgb(255, 0, 0);">3</span><span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span>;
<span style="color: rgb(0, 0, 0);">}</span>
  
<span style="color: rgb(6, 0, 255);">public</span> Run <span style="color: rgb(0, 0, 0);">(</span>data&nbsp;: <span style="color: rgb(6, 0, 255);">array</span> <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">]</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span> <span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">def</span> perm = <span style="color: rgb(6, 0, 255);">array</span> <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">10</span>, <span style="color: rgb(255, 0, 0);">7</span>, <span style="color: rgb(255, 0, 0);">11</span>, <span style="color: rgb(255, 0, 0);">0</span>, <span style="color: rgb(255, 0, 0);">12</span>, <span style="color: rgb(255, 0, 0);">5</span>, <span style="color: rgb(255, 0, 0);">14</span>, <span style="color: rgb(255, 0, 0);">6</span>, <span style="color: rgb(255, 0, 0);">9</span>, <span style="color: rgb(255, 0, 0);">4</span>, <span style="color: rgb(255, 0, 0);">13</span>, <span style="color: rgb(255, 0, 0);">2</span>, <span style="color: rgb(255, 0, 0);">1</span>, <span style="color: rgb(255, 0, 0);">8</span>, <span style="color: rgb(255, 0, 0);">3</span><span style="color: rgb(0, 0, 0);">]</span>;
  permute <span style="color: rgb(0, 0, 0);">(</span>arr, perm<span style="color: rgb(0, 0, 0);">)</span>;
  permute_specialized <span style="color: rgb(0, 0, 0);">(</span>arr<span style="color: rgb(0, 0, 0);">)</span>;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p><br>
</p>
<a name="Rewriting_interpreter_into_compiler"></a><h2> Rewriting interpreter into compiler </h2>
<a name="Virtual_machine"></a><h3> Virtual machine </h3>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(255, 0, 0);">class</span> Robot
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">mutable</span> Orientation&nbsp;: <span style="color: rgb(255, 0, 0);">byte</span>;
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">mutable</span> X&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>;
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">mutable</span> Y&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>;
&nbsp;
  <span style="color: rgb(6, 0, 255);">public</span> IsDown&nbsp;: <span style="color: rgb(255, 0, 0);">bool</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    get <span style="color: rgb(0, 0, 0);">{</span> Orientation == <span style="color: rgb(255, 0, 0);">1</span> <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">override</span> ToString <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">string</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    $<span style="color: rgb(128, 128, 128);">"($X, $Y)"</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<a name="Language"></a><h3> Language </h3>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">variant</span> Expr <span style="color: rgb(0, 0, 0);">{</span>
  | MoveBy <span style="color: rgb(0, 0, 0);">{</span> steps&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>; <span style="color: rgb(0, 0, 0);">}</span>
  | Left
  | Right
  | Value <span style="color: rgb(0, 0, 0);">{</span> prop&nbsp;: <span style="color: rgb(255, 0, 0);">string</span>; <span style="color: rgb(0, 0, 0);">}</span>
  | <span style="color: rgb(6, 0, 255);">If</span> <span style="color: rgb(0, 0, 0);">{</span> cond&nbsp;: Expr.Value; then&nbsp;: Expr; els&nbsp;: Expr; <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p><br>
</p>
<a name="Interpreter"></a><h3> Interpreter </h3>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">module</span> Scripts 
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> Run <span style="color: rgb(0, 0, 0);">(</span>obj&nbsp;: Robot, expr&nbsp;: Expr<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">def</span> check_value <span style="color: rgb(0, 0, 0);">(</span>val<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
      <span style="color: rgb(0, 0, 0);">System</span>.Convert.ToBoolean <span style="color: rgb(0, 0, 0);">(</span>obj.GetType <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>.GetProperty <span style="color: rgb(0, 0, 0);">(</span>val.prop<span style="color: rgb(0, 0, 0);">)</span>.GetValue <span style="color: rgb(0, 0, 0);">(</span>obj, <span style="color: rgb(6, 0, 255);">null</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
    <span style="color: rgb(0, 0, 0);">}</span>
    
    <span style="color: rgb(6, 0, 255);">match</span> <span style="color: rgb(0, 0, 0);">(</span>expr<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
      | Expr.MoveBy <span style="color: rgb(0, 0, 0);">(</span>steps<span style="color: rgb(0, 0, 0);">)</span> =&gt;
        <span style="color: rgb(6, 0, 255);">match</span> <span style="color: rgb(0, 0, 0);">(</span>obj.Orientation<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
          | <span style="color: rgb(255, 0, 0);">0</span> =&gt; obj.X += steps
          | <span style="color: rgb(255, 0, 0);">1</span> =&gt; obj.Y += steps
          | <span style="color: rgb(255, 0, 0);">2</span> =&gt; obj.X -= steps
          | _ =&gt; obj.Y -= steps
        <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
      | Expr.Left =&gt; obj.Orientation = <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">(</span>obj.Orientation + <span style="color: rgb(255, 0, 0);">3</span><span style="color: rgb(0, 0, 0);">)</span> % <span style="color: rgb(255, 0, 0);">4</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;:&gt; <span style="color: rgb(255, 0, 0);">byte</span>;
      | Expr.Right =&gt; obj.Orientation = <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">(</span>obj.Orientation + <span style="color: rgb(255, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">)</span> % <span style="color: rgb(255, 0, 0);">4</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;:&gt; <span style="color: rgb(255, 0, 0);">byte</span>;
&nbsp;
      | Expr.Value <span style="color: rgb(6, 0, 255);">as</span> val =&gt; _ = check_value <span style="color: rgb(0, 0, 0);">(</span>val<span style="color: rgb(0, 0, 0);">)</span>
        
      | Expr.<span style="color: rgb(6, 0, 255);">If</span> <span style="color: rgb(0, 0, 0);">(</span>val, e1, e2<span style="color: rgb(0, 0, 0);">)</span> =&gt;
        <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>check_value <span style="color: rgb(0, 0, 0);">(</span>val<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
          Run <span style="color: rgb(0, 0, 0);">(</span>obj, e1<span style="color: rgb(0, 0, 0);">)</span>
        <span style="color: rgb(6, 0, 255);">else</span>
          Run <span style="color: rgb(0, 0, 0);">(</span>obj, e2<span style="color: rgb(0, 0, 0);">)</span>
    <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
  <span style="color: rgb(6, 0, 255);">public</span> Run <span style="color: rgb(0, 0, 0);">(</span>obj&nbsp;: Robot, name&nbsp;: <span style="color: rgb(255, 0, 0);">string</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">def</span> script = GetScript <span style="color: rgb(0, 0, 0);">(</span>name<span style="color: rgb(0, 0, 0);">)</span>;
    <span style="color: rgb(6, 0, 255);">foreach</span> <span style="color: rgb(0, 0, 0);">(</span>e <span style="color: rgb(6, 0, 255);">in</span> script<span style="color: rgb(0, 0, 0);">)</span> Run <span style="color: rgb(0, 0, 0);">(</span>obj, e<span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<a name="Staged_interpreter"></a><h3> Staged interpreter </h3>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">module</span> Scripts 
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> GenerateRun <span style="color: rgb(0, 0, 0);">(</span>obj&nbsp;: PExpr, expr&nbsp;: Expr<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: PExpr
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">def</span> check_value <span style="color: rgb(0, 0, 0);">(</span>val<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
      &lt;<span style="color: rgb(0, 0, 0);">[</span> $obj.$<span style="color: rgb(0, 0, 0);">(</span>val.prop&nbsp;: dyn<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;
    <span style="color: rgb(0, 0, 0);">}</span>
    
    <span style="color: rgb(6, 0, 255);">match</span> <span style="color: rgb(0, 0, 0);">(</span>expr<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
      | Expr.MoveBy <span style="color: rgb(0, 0, 0);">(</span>steps<span style="color: rgb(0, 0, 0);">)</span> =&gt;
        &lt;<span style="color: rgb(0, 0, 0);">[</span> <span style="color: rgb(6, 0, 255);">match</span> <span style="color: rgb(0, 0, 0);">(</span>$obj.Orientation<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
             | <span style="color: rgb(255, 0, 0);">0</span> =&gt; $obj.X += $<span style="color: rgb(0, 0, 0);">(</span>steps&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span> 
             | <span style="color: rgb(255, 0, 0);">1</span> =&gt; $obj.Y += $<span style="color: rgb(0, 0, 0);">(</span>steps&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span> 
             | <span style="color: rgb(255, 0, 0);">2</span> =&gt; $obj.X -= $<span style="color: rgb(0, 0, 0);">(</span>steps&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span> 
             | _ =&gt; $obj.Y -= $<span style="color: rgb(0, 0, 0);">(</span>steps&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>
           <span style="color: rgb(0, 0, 0);">}</span>
        <span style="color: rgb(0, 0, 0);">]</span>&gt;
&nbsp;
      | Expr.Left =&gt; &lt;<span style="color: rgb(0, 0, 0);">[</span> $obj.Orientation = <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">(</span>$obj.Orientation + <span style="color: rgb(255, 0, 0);">3</span><span style="color: rgb(0, 0, 0);">)</span> % <span style="color: rgb(255, 0, 0);">4</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;:&gt; <span style="color: rgb(255, 0, 0);">byte</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;;
      | Expr.Right =&gt; &lt;<span style="color: rgb(0, 0, 0);">[</span> $obj.Orientation = <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">(</span>$obj.Orientation + <span style="color: rgb(255, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">)</span> % <span style="color: rgb(255, 0, 0);">4</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;:&gt; <span style="color: rgb(255, 0, 0);">byte</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;;
      | Expr.Value <span style="color: rgb(6, 0, 255);">as</span> val =&gt; &lt;<span style="color: rgb(0, 0, 0);">[</span> _ = $<span style="color: rgb(0, 0, 0);">(</span>check_value <span style="color: rgb(0, 0, 0);">(</span>val<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;
        
      | Expr.<span style="color: rgb(6, 0, 255);">If</span> <span style="color: rgb(0, 0, 0);">(</span>val, e1, e2<span style="color: rgb(0, 0, 0);">)</span> =&gt;
        &lt;<span style="color: rgb(0, 0, 0);">[</span> <span style="color: rgb(6, 0, 255);">if</span> <span style="color: rgb(0, 0, 0);">(</span>$<span style="color: rgb(0, 0, 0);">(</span>check_value <span style="color: rgb(0, 0, 0);">(</span>val<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
             $<span style="color: rgb(0, 0, 0);">(</span>GenerateRun <span style="color: rgb(0, 0, 0);">(</span>obj, e1<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
           <span style="color: rgb(6, 0, 255);">else</span>
             $<span style="color: rgb(0, 0, 0);">(</span>GenerateRun <span style="color: rgb(0, 0, 0);">(</span>obj, e2<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
        <span style="color: rgb(0, 0, 0);">]</span>&gt;
    <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
<span style="color: rgb(6, 0, 255);">macro</span> GenerateRun <span style="color: rgb(0, 0, 0);">(</span>obj, name&nbsp;: <span style="color: rgb(255, 0, 0);">string</span><span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">def</span> script = Scripts.GetScript <span style="color: rgb(0, 0, 0);">(</span>name<span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(6, 0, 255);">def</span> exprs = List.Map <span style="color: rgb(0, 0, 0);">(</span>script, <span style="color: rgb(6, 0, 255);">fun</span> <span style="color: rgb(0, 0, 0);">(</span>e<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span> Scripts.GenerateRun <span style="color: rgb(0, 0, 0);">(</span>obj, e<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">}</span><span style="color: rgb(0, 0, 0);">)</span>;
  &lt;<span style="color: rgb(0, 0, 0);">[</span> <span style="color: rgb(0, 0, 0);">{</span> ..$exprs <span style="color: rgb(0, 0, 0);">}</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p><br>
</p>
<a name="Usage"></a><h3> Usage </h3>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">def</span> x = Robot <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
Scripts.Run <span style="color: rgb(0, 0, 0);">(</span>x, <span style="color: rgb(128, 128, 128);">"myscript1"</span><span style="color: rgb(0, 0, 0);">)</span>;
<span style="color: rgb(0, 0, 0);">System</span>.Console.WriteLine <span style="color: rgb(0, 0, 0);">(</span>x<span style="color: rgb(0, 0, 0);">)</span>;    
GenerateRun <span style="color: rgb(0, 0, 0);">(</span>x, <span style="color: rgb(128, 128, 128);">"myscript1"</span><span style="color: rgb(0, 0, 0);">)</span>;    
<span style="color: rgb(0, 0, 0);">System</span>.Console.WriteLine <span style="color: rgb(0, 0, 0);">(</span>x<span style="color: rgb(0, 0, 0);">)</span>;</pre>

<!-- Saved in parser cache with key wiki:pcache:idhash:736-0!1!0!0!!en!2 and timestamp 20060121184254 -->
<a name="chunk-Design_patterns"></a>
	  	  <h1 class="firstHeading">Design patterns</h1>
	    	    	    <!-- start content -->
	    <table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Intro"><span class="tocnumber">1</span> <span class="toctext">Intro</span></a></li>
<li class="toclevel-1"><a href="#Proxy_design_pattern"><span class="tocnumber">2</span> <span class="toctext">Proxy design pattern</span></a>
<ul>
<li class="toclevel-2"><a href="#What_we_want_to_achieve"><span class="tocnumber">2.1</span> <span class="toctext">What we want to achieve</span></a></li>
<li class="toclevel-2"><a href="#How_we_do_this_with_a_macro"><span class="tocnumber">2.2</span> <span class="toctext">How we do this with a macro</span></a></li>
<li class="toclevel-2"><a href="#Macro_included_in_standard_library"><span class="tocnumber">2.3</span> <span class="toctext">Macro included in standard library</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Singleton_design_pattern"><span class="tocnumber">3</span> <span class="toctext">Singleton design pattern</span></a>
<ul>
<li class="toclevel-2"><a href="#What_do_we_want_to_achieve.3F"><span class="tocnumber">3.1</span> <span class="toctext">What do we want to achieve?</span></a></li>
<li class="toclevel-2"><a href="#How_do_we_implement_it_in_macro.3F"><span class="tocnumber">3.2</span> <span class="toctext">How do we implement it in macro?</span></a></li>
</ul>
</li>
</ul>
</td></tr></tbody></table>
<p><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
</p>
<a name="Intro"></a><h2> Intro </h2>
<p><a href="http://www.dofactory.com/Patterns/Patterns.aspx" class="external text" title="http://www.dofactory.com/Patterns/Patterns.aspx">Design patterns</a>
are meant to ease programmers' work by distinguishing various common
schemas of creating software and solving most often occuring problems.
Most of them involve some particular interaction between objects in
program, which can be easily identified and named.
</p><p>The downside of many design patterns is that they often require
implementing massive amount of code, which tends always to be the same
or almost the same. Some patterns just point out how particular objects
could communicate or what should be the inheritance hierarchy of
classes representing given model. These patterns are just hints for
programmers what is the preferred way of structuring their programs in
choosen situations. Unfortunately others often imply large dumb work
for programmers trying to follow them. They need to override <i>n-th</i> method from the <i>k-th</i> class by adding the same code as in all <i>0..n-1</i>
previous methods. This kind of job is not only boring, but also is a
waste of developer's time and will probably be a nightmare to maintain.
</p><p>There comes a solution from metaprogramming. We could just
write a generator for all those methods, wrappers, auxiliary instances,
etc. In this document we present examples of choosen design patterns,
where often repeating code may be generated instead of hand written.
</p>
<a name="Proxy_design_pattern"></a><h2> Proxy design pattern </h2>
<p><a href="http://www.dofactory.com/Patterns/PatternProxy.aspx" class="external text" title="http://www.dofactory.com/Patterns/PatternProxy.aspx">Proxy pattern</a> is based on forwarding calls to some object <i>A</i> into calls to another object <i>B</i>. Usually the object <i>B</i> is contained in an instance field of <i>A</i>. The point of this is to imitate behavior of <i>B</i> in a new class. We can even implement <i>B'</i>s interface in <i>A</i> by simply passing all calls to <i>B</i>. We can then override some of these methods with new behaviour.
</p><p>The solution presented is also very similar to <a href="http://lab.msdn.microsoft.com/productfeedback/viewfeedback.aspx?feedbackid=FDBK21603" class="external text" title="http://lab.msdn.microsoft.com/productfeedback/viewfeedback.aspx?feedbackid=FDBK21603">implicit interface implementation through aggregation</a>, one of many niched suggestions about C# language.
</p>
<a name="What_we_want_to_achieve"></a><h3> What we want to achieve </h3>
<p>Suppose we have an interface <tt>IMath</tt> and an object <tt>Math</tt> implementing this interface. <tt>Math</tt> will be the object stored on server and we will create a representative object that controls access to it in a different <i>AppDomain</i>.
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">using</span> <span style="color: rgb(0, 0, 0);">System</span>;
<span style="color: rgb(6, 0, 255);">using</span> <span style="color: rgb(0, 0, 0);">System</span>.Runtime.Remoting;
&nbsp;
<span style="color: rgb(0, 128, 128); font-style: italic;">// "Subject"</span>
&nbsp;
<span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(255, 0, 0);">interface</span> IMath
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(0, 128, 128); font-style: italic;">// Methods</span>
   Add<span style="color: rgb(0, 0, 0);">(</span> x&nbsp;:  <span style="color: rgb(255, 0, 0);">double</span>, y&nbsp;: <span style="color: rgb(255, 0, 0);">double</span> <span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">double</span>;
   Sub<span style="color: rgb(0, 0, 0);">(</span> x&nbsp;:  <span style="color: rgb(255, 0, 0);">double</span>, y&nbsp;: <span style="color: rgb(255, 0, 0);">double</span> <span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">double</span>;
   Mul<span style="color: rgb(0, 0, 0);">(</span> x&nbsp;:  <span style="color: rgb(255, 0, 0);">double</span>, y&nbsp;: <span style="color: rgb(255, 0, 0);">double</span> <span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">double</span>;
   Div<span style="color: rgb(0, 0, 0);">(</span> x&nbsp;:  <span style="color: rgb(255, 0, 0);">double</span>, y&nbsp;: <span style="color: rgb(255, 0, 0);">double</span> <span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">double</span>;
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
<span style="color: rgb(0, 128, 128); font-style: italic;">// "RealSubject"</span>
&nbsp;
<span style="color: rgb(255, 0, 0);">class</span> Math&nbsp;: MarshalByRefObject, IMath
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(0, 128, 128); font-style: italic;">// Methods</span>
  <span style="color: rgb(6, 0, 255);">public</span> Add<span style="color: rgb(0, 0, 0);">(</span>x&nbsp;: <span style="color: rgb(255, 0, 0);">double</span>, y&nbsp;: <span style="color: rgb(255, 0, 0);">double</span> <span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">double</span> <span style="color: rgb(0, 0, 0);">{</span> x + y; <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(6, 0, 255);">public</span> Sub<span style="color: rgb(0, 0, 0);">(</span>x&nbsp;: <span style="color: rgb(255, 0, 0);">double</span>, y&nbsp;: <span style="color: rgb(255, 0, 0);">double</span> <span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">double</span> <span style="color: rgb(0, 0, 0);">{</span> x - y; <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(6, 0, 255);">public</span> Mul<span style="color: rgb(0, 0, 0);">(</span>x&nbsp;: <span style="color: rgb(255, 0, 0);">double</span>, y&nbsp;: <span style="color: rgb(255, 0, 0);">double</span> <span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">double</span> <span style="color: rgb(0, 0, 0);">{</span> x * y; <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(6, 0, 255);">public</span> Div<span style="color: rgb(0, 0, 0);">(</span>x&nbsp;: <span style="color: rgb(255, 0, 0);">double</span>, y&nbsp;: <span style="color: rgb(255, 0, 0);">double</span> <span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(255, 0, 0);">double</span> <span style="color: rgb(0, 0, 0);">{</span> x / y; <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>Now for accessing <tt>Math</tt> in different <i>AppDomain</i> we create a <tt>MathProxy</tt>, which will provide full functionality of <tt>IMath</tt>. Internally it will use <tt>Math</tt> instance to implement all that functionality.
</p><p>The point is that forwarding every call in <tt>IMath</tt> requires a considerable amount of code to be written. We will use a macro, which generates needed methods automatically.
</p>
<pre class="nemerle"><span style="color: rgb(0, 128, 128); font-style: italic;">// Remote "Proxy Object"</span>
<span style="color: rgb(255, 0, 0);">class</span> MathProxy&nbsp;: IMath
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(0, 128, 128); font-style: italic;">// the stubs implementing IMath by calling math.* are automatically generated</span>
  <span style="color: rgb(0, 0, 0);">[</span>DesignPatterns.Proxy <span style="color: rgb(0, 0, 0);">(</span>IMath<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">]</span>
  math&nbsp;: Math;
  
  <span style="color: rgb(0, 128, 128); font-style: italic;">// Constructors</span>
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">this</span><span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(0, 128, 128); font-style: italic;">// Create Math instance in a different AppDomain</span>
    <span style="color: rgb(6, 0, 255);">def</span> ad = <span style="color: rgb(0, 0, 0);">System</span>.AppDomain.CreateDomain<span style="color: rgb(0, 0, 0);">(</span> <span style="color: rgb(128, 128, 128);">"MathDomain"</span>,<span style="color: rgb(6, 0, 255);">null</span>, <span style="color: rgb(6, 0, 255);">null</span> <span style="color: rgb(0, 0, 0);">)</span>;
    <span style="color: rgb(6, 0, 255);">def</span> o =
      ad.CreateInstance<span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"Proxy_RealWorld"</span>, <span style="color: rgb(128, 128, 128);">"Math"</span>, <span style="color: rgb(6, 0, 255);">false</span>,
                        <span style="color: rgb(0, 0, 0);">System</span>.Reflection.BindingFlags.CreateInstance, <span style="color: rgb(6, 0, 255);">null</span>, 
                        <span style="color: rgb(6, 0, 255);">null</span>, <span style="color: rgb(6, 0, 255);">null</span>,null,<span style="color: rgb(6, 0, 255);">null</span> <span style="color: rgb(0, 0, 0);">)</span>;
    math = <span style="color: rgb(0, 0, 0);">(</span> o.Unwrap<span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;:&gt; Math<span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>As the comment says, for each method in <tt>IMath</tt> interface the implementation will be automatically created in a way similar to
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(255, 0, 0);">double</span> Add<span style="color: rgb(0, 0, 0);">(</span> x&nbsp;: <span style="color: rgb(255, 0, 0);">double</span>, y&nbsp;: <span style="color: rgb(255, 0, 0);">double</span> <span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
  math.Add<span style="color: rgb(0, 0, 0);">(</span>x,y<span style="color: rgb(0, 0, 0);">)</span>;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>so we can then use <tt>MathProxy</tt> as
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(255, 0, 0);">class</span> ProxyApp
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">static</span> Main<span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;:  <span style="color: rgb(6, 0, 255);">void</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(0, 128, 128); font-style: italic;">// Create math proxy</span>
    <span style="color: rgb(6, 0, 255);">def</span>  p =  MathProxy<span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
&nbsp;
    <span style="color: rgb(0, 128, 128); font-style: italic;">// Do the math</span>
    Console.WriteLine<span style="color: rgb(0, 0, 0);">(</span> <span style="color: rgb(128, 128, 128);">"4 + 2 = {0}"</span>, p.Add<span style="color: rgb(0, 0, 0);">(</span> <span style="color: rgb(255, 0, 0);">4</span>.<span style="color: rgb(255, 0, 0);">0</span>, <span style="color: rgb(255, 0, 0);">2</span>.<span style="color: rgb(255, 0, 0);">0</span> <span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">)</span>;
    Console.WriteLine<span style="color: rgb(0, 0, 0);">(</span> <span style="color: rgb(128, 128, 128);">"4 - 2 = {0}"</span>, p.Sub<span style="color: rgb(0, 0, 0);">(</span> <span style="color: rgb(255, 0, 0);">4</span>.<span style="color: rgb(255, 0, 0);">0</span>, <span style="color: rgb(255, 0, 0);">2</span>.<span style="color: rgb(255, 0, 0);">0</span> <span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">)</span>;
    Console.WriteLine<span style="color: rgb(0, 0, 0);">(</span> <span style="color: rgb(128, 128, 128);">"4 * 2 = {0}"</span>, p.Mul<span style="color: rgb(0, 0, 0);">(</span> <span style="color: rgb(255, 0, 0);">4</span>.<span style="color: rgb(255, 0, 0);">0</span>, <span style="color: rgb(255, 0, 0);">2</span>.<span style="color: rgb(255, 0, 0);">0</span> <span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">)</span>;
    Console.WriteLine<span style="color: rgb(0, 0, 0);">(</span> <span style="color: rgb(128, 128, 128);">"4 / 2 = {0}"</span>, p.Div<span style="color: rgb(0, 0, 0);">(</span> <span style="color: rgb(255, 0, 0);">4</span>.<span style="color: rgb(255, 0, 0);">0</span>, <span style="color: rgb(255, 0, 0);">2</span>.<span style="color: rgb(255, 0, 0);">0</span> <span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<a name="How_we_do_this_with_a_macro"></a><h3> How we do this with a macro </h3>
<p>In code above we used an attribute <tt>[DesignPatterns.Proxy (IMath)]</tt>. Actually it is a macro, which is invoked by compiler and will do what we need.
</p><p>The implementation is presented below. It uses some of the compiler's API, but we will briefly describe what happens here.
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">using</span> <span style="color: rgb(0, 0, 0);">Nemerle</span>.Compiler;
<span style="color: rgb(6, 0, 255);">using</span> <span style="color: rgb(0, 0, 0);">Nemerle</span>.Collections;
&nbsp;
<span style="color: rgb(6, 0, 255);">namespace</span> DesignPatterns
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(0, 0, 0);">Nemerle</span>.MacroUsage <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">Nemerle</span>.MacroPhase.WithTypedMembers,
                       <span style="color: rgb(0, 0, 0);">Nemerle</span>.MacroTargets.Field<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">]</span>
  <span style="color: rgb(6, 0, 255);">macro</span> Proxy <span style="color: rgb(0, 0, 0);">(</span>t&nbsp;: TypeBuilder, f&nbsp;: FieldBuilder, iface<span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(0, 128, 128); font-style: italic;">// find out the real type specified as [iface] parameter</span>
    <span style="color: rgb(6, 0, 255);">def</span> interfc = <span style="color: rgb(6, 0, 255);">match</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">Nemerle</span>.Macros.ImplicitCTX<span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>.BindType <span style="color: rgb(0, 0, 0);">(</span>iface<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
    <span style="color: rgb(0, 0, 0);">{</span>
      | MType.<span style="color: rgb(255, 0, 0);">Class</span> <span style="color: rgb(0, 0, 0);">(</span>typeinfo, _<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(6, 0, 255);">when</span> typeinfo.IsInterface =&gt; typeinfo
      | _ =&gt; Message.FatalError <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"expected interface type"</span><span style="color: rgb(0, 0, 0);">)</span>
    <span style="color: rgb(0, 0, 0);">}</span>
    <span style="color: rgb(6, 0, 255);">foreach</span> <span style="color: rgb(0, 0, 0);">(</span>meth&nbsp;:&gt; IMethod <span style="color: rgb(6, 0, 255);">in</span> interfc.GetMembers <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
    <span style="color: rgb(0, 0, 0);">{</span>
          <span style="color: rgb(0, 128, 128); font-style: italic;">// prepare interface method invocation arguments</span>
          <span style="color: rgb(6, 0, 255);">def</span> parms = List.Map <span style="color: rgb(0, 0, 0);">(</span>meth.GetParameters <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>, <span style="color: rgb(6, 0, 255);">fun</span> <span style="color: rgb(0, 0, 0);">(</span>p<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
            &lt;<span style="color: rgb(0, 0, 0);">[</span> $<span style="color: rgb(0, 0, 0);">(</span>t.ParsedName.NewName <span style="color: rgb(0, 0, 0);">(</span>p.name<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: name<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: $<span style="color: rgb(0, 0, 0);">(</span>p.ty&nbsp;: typed<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;
          <span style="color: rgb(0, 0, 0);">}</span><span style="color: rgb(0, 0, 0);">)</span>;
          <span style="color: rgb(0, 128, 128); font-style: italic;">// prepare function parameters of created method</span>
          <span style="color: rgb(6, 0, 255);">def</span> fparms = List.Map <span style="color: rgb(0, 0, 0);">(</span>parms, Parsetree.Fun_parm<span style="color: rgb(0, 0, 0);">)</span>;
&nbsp;
          <span style="color: rgb(0, 128, 128); font-style: italic;">// define the wrapper method</span>
          t.Define <span style="color: rgb(0, 0, 0);">(</span>&lt;<span style="color: rgb(0, 0, 0);">[</span> decl:
            <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">virtual</span> $<span style="color: rgb(0, 0, 0);">(</span>meth.Name&nbsp;: dyn<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">(</span>..$fparms<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: $<span style="color: rgb(0, 0, 0);">(</span>meth.ReturnType&nbsp;: typed<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
              <span style="color: rgb(6, 0, 255);">this</span>.$<span style="color: rgb(0, 0, 0);">(</span>f.Name&nbsp;: dyn<span style="color: rgb(0, 0, 0);">)</span>.$<span style="color: rgb(0, 0, 0);">(</span>meth.Name&nbsp;: dyn<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">(</span>..$parms<span style="color: rgb(0, 0, 0);">)</span>
            <span style="color: rgb(0, 0, 0);">}</span>
          <span style="color: rgb(0, 0, 0);">]</span>&gt;<span style="color: rgb(0, 0, 0);">)</span>
    <span style="color: rgb(0, 0, 0);">}</span> 
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>Our macro takes as a parameter the name of interface, for which we
need to create methods. This is just a plain expression, so we need to
ask compiler what it really is and if it really describes an interface.
We get an instance of <a href="http://nemerle.org/doc/Nemerle.Compiler.TypeInfo.html" class="external text" title="http://nemerle.org/doc/Nemerle.Compiler.TypeInfo.html">Nemerle.Complier.TypeInfo</a> this way. 
</p><p>Then we iterate over members of this interface type, casting them to <tt>IMethod</tt> interface. From this interface we can obtain all information needed about the method. Its name and parameters.
</p><p>The process of generating new method's declaration is a little
bit complex. We must separately create expressions describing its
parameters and expressions for method invocation. Finally we create
code for calling method on the field for which our macro was used.
</p>
<a name="Macro_included_in_standard_library"></a><h3> Macro included in standard library </h3>
<p>Since version 0.9.2 of Nemerle, the slightly modified version of Proxy macro has been included into standard macros library.
It can be accessed via <i>Nemerle.DesignPatterns.ProxyPublicMembers</i>. It creates wrappers for public members like methods
and properties from given field to current type. 
</p><p>So if you have a class 
</p>
<pre class="nemerle"><span style="color: rgb(255, 0, 0);">class</span> Foo <span style="color: rgb(0, 0, 0);">[</span>'a<span style="color: rgb(0, 0, 0);">]</span> <span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> Length&nbsp;: <span style="color: rgb(255, 0, 0);">int</span> <span style="color: rgb(0, 0, 0);">{</span>
    get <span style="color: rgb(0, 0, 0);">{</span> .. <span style="color: rgb(0, 0, 0);">}</span> 
  <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(6, 0, 255);">public</span> Fire <span style="color: rgb(0, 0, 0);">(</span>x&nbsp;: <span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span> <span style="color: rgb(0, 0, 0);">{</span>  <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(6, 0, 255);">public</span> Gene <span style="color: rgb(0, 0, 0);">(</span>x&nbsp;: 'a<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: 'a <span style="color: rgb(0, 0, 0);">{</span> x <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>you can automatically duplicate its methods in your class like
</p>
<pre class="nemerle"><span style="color: rgb(0, 0, 0);">[</span>Record<span style="color: rgb(0, 0, 0);">]</span>
<span style="color: rgb(255, 0, 0);">class</span> Bar <span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(0, 0, 0);">Nemerle</span>.DesignPatterns.ProxyPublicMembers <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">]</span>
  my_foo&nbsp;: Foo <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">int</span><span style="color: rgb(0, 0, 0);">]</span>;
<span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
<span style="color: rgb(6, 0, 255);">def</span> bar = Bar <span style="color: rgb(0, 0, 0);">(</span>Foo <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>;
_ = bar.Length;
bar.Fire <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">)</span>;
_ = bar.Gene <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">1</span><span style="color: rgb(0, 0, 0);">)</span>;</pre>
<a name="Singleton_design_pattern"></a><h2> Singleton design pattern </h2>
<p><a href="http://www.dofactory.com/Patterns/PatternSingleton.aspx" class="external text" title="http://www.dofactory.com/Patterns/PatternSingleton.aspx">Singleton Design Pattern</a>
ensures a class has only one instance and provide a global point of
access to it. It lets you encapsulate and control the creation process
by making sure that certain prerequisites are fulfilled or by creating
the object lazily on demand.
</p>
<a name="What_do_we_want_to_achieve.3F"></a><h3> What do we want to achieve? </h3>
<p>We want to have a class, which will be automatically created when
requested and then the created instance will be stored for any futher
requests. We just want to specify the name of property by which we will
access class' instance and write the needed logic. Management of lazy
creation and storage should be hidden, because it does not introduce
any valuable information. </p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">using</span> <span style="color: rgb(0, 0, 0);">System</span>;
<span style="color: rgb(6, 0, 255);">using</span> <span style="color: rgb(0, 0, 0);">Nemerle</span>.Collections;
<span style="color: rgb(6, 0, 255);">using</span> <span style="color: rgb(0, 0, 0);">System</span>.Threading;
&nbsp;
<span style="color: rgb(0, 128, 128); font-style: italic;">// "Singleton"</span>
&nbsp;
<span style="color: rgb(0, 0, 0);">[</span>DesignPatterns.Singleton <span style="color: rgb(0, 0, 0);">(</span>GetLoadBalancer<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">]</span>
<span style="color: rgb(255, 0, 0);">class</span> LoadBalancer
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">private</span> servers&nbsp;: Vector <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(255, 0, 0);">string</span><span style="color: rgb(0, 0, 0);">]</span> = Vector <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">5</span><span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(6, 0, 255);">private</span> random&nbsp;: Random = Random <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
&nbsp;
  <span style="color: rgb(0, 128, 128); font-style: italic;">// Constructors (protected)</span>
  <span style="color: rgb(6, 0, 255);">protected</span> <span style="color: rgb(6, 0, 255);">this</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(0, 128, 128); font-style: italic;">// List of available servers</span>
    servers.Add<span style="color: rgb(0, 0, 0);">(</span> <span style="color: rgb(128, 128, 128);">"ServerI"</span> <span style="color: rgb(0, 0, 0);">)</span>;
    servers.Add<span style="color: rgb(0, 0, 0);">(</span> <span style="color: rgb(128, 128, 128);">"ServerII"</span> <span style="color: rgb(0, 0, 0);">)</span>;
    servers.Add<span style="color: rgb(0, 0, 0);">(</span> <span style="color: rgb(128, 128, 128);">"ServerIII"</span> <span style="color: rgb(0, 0, 0);">)</span>;
    servers.Add<span style="color: rgb(0, 0, 0);">(</span> <span style="color: rgb(128, 128, 128);">"ServerIV"</span> <span style="color: rgb(0, 0, 0);">)</span>;
    servers.Add<span style="color: rgb(0, 0, 0);">(</span> <span style="color: rgb(128, 128, 128);">"ServerV"</span> <span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(0, 0, 0);">}</span>
&nbsp;
  <span style="color: rgb(0, 128, 128); font-style: italic;">// Properties</span>
  <span style="color: rgb(6, 0, 255);">public</span> Server&nbsp;: <span style="color: rgb(255, 0, 0);">string</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    get
    <span style="color: rgb(0, 0, 0);">{</span>
      <span style="color: rgb(0, 128, 128); font-style: italic;">// Simple, but effective random load balancer</span>
      <span style="color: rgb(6, 0, 255);">def</span> r = random.Next <span style="color: rgb(0, 0, 0);">(</span>servers.Count<span style="color: rgb(0, 0, 0);">)</span>;
      servers <span style="color: rgb(0, 0, 0);">[</span>r<span style="color: rgb(0, 0, 0);">]</span>;
    <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p><tt>[DesignPatterns.Singleton (GetLoadBalancer)]</tt> attribute specifies that given class will be a singleton and that its instance will be accessed through property <i>GetLoadBalancer</i>. 
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(255, 0, 0);">class</span> SingletonApp
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">static</span> Main<span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">def</span> b1 = LoadBalancer.GetLoadBalancer;
    <span style="color: rgb(6, 0, 255);">def</span> b2 = LoadBalancer.GetLoadBalancer;
    <span style="color: rgb(6, 0, 255);">def</span> b3 = LoadBalancer.GetLoadBalancer;
    <span style="color: rgb(6, 0, 255);">def</span> b4 = LoadBalancer.GetLoadBalancer;
&nbsp;
    <span style="color: rgb(0, 128, 128); font-style: italic;">// Same instance?</span>
    <span style="color: rgb(6, 0, 255);">when</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">(</span>b1&nbsp;: <span style="color: rgb(255, 0, 0);">object</span> == b2<span style="color: rgb(0, 0, 0);">)</span> &amp;&amp; <span style="color: rgb(0, 0, 0);">(</span>b2&nbsp;: <span style="color: rgb(255, 0, 0);">object</span> == b3<span style="color: rgb(0, 0, 0);">)</span> &amp;&amp; <span style="color: rgb(0, 0, 0);">(</span>b3&nbsp;: <span style="color: rgb(255, 0, 0);">object</span> == b4<span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">)</span>
      Console.WriteLine<span style="color: rgb(0, 0, 0);">(</span> <span style="color: rgb(128, 128, 128);">"Same instance"</span> <span style="color: rgb(0, 0, 0);">)</span>;
&nbsp;
    <span style="color: rgb(0, 128, 128); font-style: italic;">// Do the load balancing</span>
    Console.WriteLine<span style="color: rgb(0, 0, 0);">(</span> b1.Server <span style="color: rgb(0, 0, 0);">)</span>;
    Console.WriteLine<span style="color: rgb(0, 0, 0);">(</span> b2.Server <span style="color: rgb(0, 0, 0);">)</span>;
    Console.WriteLine<span style="color: rgb(0, 0, 0);">(</span> b3.Server <span style="color: rgb(0, 0, 0);">)</span>;
    Console.WriteLine<span style="color: rgb(0, 0, 0);">(</span> b4.Server <span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<a name="How_do_we_implement_it_in_macro.3F"></a><h3> How do we implement it in macro? </h3>
<p>The task of a macro will be to
</p>
<ul><li>create a field for storing the only instance
</li><li>create the property for accessing it, which will lazily call the constructor
</li><li>make sure that there is only one constructor and make sure it is protected
</li></ul>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">using</span> <span style="color: rgb(0, 0, 0);">Nemerle</span>.Compiler;
<span style="color: rgb(6, 0, 255);">using</span> <span style="color: rgb(0, 0, 0);">Nemerle</span>.Collections;
&nbsp;
<span style="color: rgb(6, 0, 255);">namespace</span> DesignPatterns
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(0, 0, 0);">[</span><span style="color: rgb(0, 0, 0);">Nemerle</span>.MacroUsage <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">Nemerle</span>.MacroPhase.BeforeInheritance,
                       <span style="color: rgb(0, 0, 0);">Nemerle</span>.MacroTargets.<span style="color: rgb(255, 0, 0);">Class</span><span style="color: rgb(0, 0, 0);">)</span><span style="color: rgb(0, 0, 0);">]</span>
  <span style="color: rgb(6, 0, 255);">macro</span> Singleton <span style="color: rgb(0, 0, 0);">(</span>t&nbsp;: TypeBuilder, getter<span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(6, 0, 255);">def</span> mems = t.GetParsedMembers <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
    <span style="color: rgb(0, 128, 128); font-style: italic;">// find constructor, which we will need to call</span>
    <span style="color: rgb(0, 128, 128); font-style: italic;">// to create instance</span>
    <span style="color: rgb(6, 0, 255);">def</span> ctor = List.Filter <span style="color: rgb(0, 0, 0);">(</span>mems, <span style="color: rgb(6, 0, 255);">fun</span> <span style="color: rgb(0, 0, 0);">(</span>x<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
      | &lt;<span style="color: rgb(0, 0, 0);">[</span> decl: ..$_ <span style="color: rgb(6, 0, 255);">this</span> <span style="color: rgb(0, 0, 0);">(</span>..$_<span style="color: rgb(0, 0, 0);">)</span> $_ <span style="color: rgb(0, 0, 0);">]</span>&gt; =&gt; <span style="color: rgb(6, 0, 255);">true</span>
      | _ =&gt; <span style="color: rgb(6, 0, 255);">false</span>
    <span style="color: rgb(0, 0, 0);">}</span><span style="color: rgb(0, 0, 0);">)</span>;
    <span style="color: rgb(6, 0, 255);">match</span> <span style="color: rgb(0, 0, 0);">(</span>ctor<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
      | <span style="color: rgb(0, 0, 0);">[</span> &lt;<span style="color: rgb(0, 0, 0);">[</span> decl: ..$_ <span style="color: rgb(6, 0, 255);">this</span> <span style="color: rgb(0, 0, 0);">(</span>..$parms<span style="color: rgb(0, 0, 0);">)</span> $_ <span style="color: rgb(0, 0, 0);">]</span>&gt; <span style="color: rgb(6, 0, 255);">as</span> constructor <span style="color: rgb(0, 0, 0);">]</span> =&gt;
        <span style="color: rgb(6, 0, 255);">match</span> <span style="color: rgb(0, 0, 0);">(</span>getter<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
          | &lt;<span style="color: rgb(0, 0, 0);">[</span> $<span style="color: rgb(0, 0, 0);">(</span>getter_name&nbsp;: name<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">]</span>&gt; =&gt;
            <span style="color: rgb(0, 128, 128); font-style: italic;">// we must prepare expressions for invoking constructor</span>
            <span style="color: rgb(6, 0, 255);">def</span> invoke_parms = List.Map <span style="color: rgb(0, 0, 0);">(</span>parms, <span style="color: rgb(6, 0, 255);">fun</span> <span style="color: rgb(0, 0, 0);">(</span>x<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
              &lt;<span style="color: rgb(0, 0, 0);">[</span> $<span style="color: rgb(0, 0, 0);">(</span>x.ParsedName&nbsp;: name<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;
            <span style="color: rgb(0, 0, 0);">}</span><span style="color: rgb(0, 0, 0);">)</span>;
            
            <span style="color: rgb(0, 128, 128); font-style: italic;">// first define the filed, where a single instance will be stored</span>
            t.Define <span style="color: rgb(0, 0, 0);">(</span>&lt;<span style="color: rgb(0, 0, 0);">[</span> decl:
              <span style="color: rgb(6, 0, 255);">private</span> <span style="color: rgb(6, 0, 255);">static</span> <span style="color: rgb(6, 0, 255);">mutable</span> instance&nbsp;: $<span style="color: rgb(0, 0, 0);">(</span>t.ParsedName&nbsp;: name<span style="color: rgb(0, 0, 0);">)</span>;
            <span style="color: rgb(0, 0, 0);">]</span>&gt;<span style="color: rgb(0, 0, 0);">)</span>;
&nbsp;
            <span style="color: rgb(0, 128, 128); font-style: italic;">// finally, define getter</span>
            t.Define <span style="color: rgb(0, 0, 0);">(</span>&lt;<span style="color: rgb(0, 0, 0);">[</span> decl:
              <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">static</span> $<span style="color: rgb(0, 0, 0);">(</span>getter_name&nbsp;: name<span style="color: rgb(0, 0, 0);">)</span>&nbsp;: $<span style="color: rgb(0, 0, 0);">(</span>t.ParsedName&nbsp;: name<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
                get <span style="color: rgb(0, 0, 0);">{</span>
                  <span style="color: rgb(0, 128, 128); font-style: italic;">// lazy initialization in generated code</span>
                  <span style="color: rgb(6, 0, 255);">when</span> <span style="color: rgb(0, 0, 0);">(</span>instance == <span style="color: rgb(6, 0, 255);">null</span><span style="color: rgb(0, 0, 0);">)</span>
                    instance = $<span style="color: rgb(0, 0, 0);">(</span>t.ParsedName&nbsp;: name<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">(</span>..$invoke_parms<span style="color: rgb(0, 0, 0);">)</span>;
                  instance;
                <span style="color: rgb(0, 0, 0);">}</span>
              <span style="color: rgb(0, 0, 0);">}</span> 
            <span style="color: rgb(0, 0, 0);">]</span>&gt;<span style="color: rgb(0, 0, 0);">)</span>;
&nbsp;
            <span style="color: rgb(0, 128, 128); font-style: italic;">// make sure constructor is protected</span>
            constructor.Attributes |= NemerleAttributes.<span style="color: rgb(6, 0, 255);">Protected</span>;
           
          | _ =&gt;
            Message.FatalError <span style="color: rgb(0, 0, 0);">(</span>$<span style="color: rgb(128, 128, 128);">"Singleton must be supplied with a simple name for getter, got $getter"</span><span style="color: rgb(0, 0, 0);">)</span>
        <span style="color: rgb(0, 0, 0);">}</span>
      | _ =&gt; Message.Error <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"Singleton design pattern requires exactly one constructor defined"</span><span style="color: rgb(0, 0, 0);">)</span>
    <span style="color: rgb(0, 0, 0);">}</span> 
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>First we search through members of the class and find all constructors. We make sure there is only one, read its parameters. 
After building expressions for invoking constructor we define needed class members.
Finally constructor is marked as <i>protected</i>.
</p>
<!-- Saved in parser cache with key wiki:pcache:idhash:1009-0!1!0!0!!en!2 and timestamp 20060121191628 -->
<a name="chunk-Syntax_extensions"></a>
	  	  <h1 class="firstHeading">Syntax extensions</h1>
	    	    	    <!-- start content -->
	    <p>Nemerle
has builtin syntax extension capabilities. They are limited to some
fixed elements of language grammar, but their ability to defer parsing
of entire fragments of token stream makes them quite powerful and
usable.
</p><p><b>Note:</b> Remember that in order <b>to compile</b> anything that has a macro in it, you must use <code>ncc -r Nemerle.Compiler.dll <i>foo.n</i></code> or similar.
</p><p><br>
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#Expression_level_extensions"><span class="tocnumber">1</span> <span class="toctext">Expression level extensions</span></a></li>
<li class="toclevel-1"><a href="#Raw_token_extensions"><span class="tocnumber">2</span> <span class="toctext">Raw token extensions</span></a>
<ul>
<li class="toclevel-2"><a href="#The_parentheses_tree_concept"><span class="tocnumber">2.1</span> <span class="toctext">The parentheses tree concept</span></a></li>
<li class="toclevel-2"><a href="#Parentheses_tokens"><span class="tocnumber">2.2</span> <span class="toctext">Parentheses tokens</span></a></li>
<li class="toclevel-2"><a href="#Passing_token_groups_to_the_macro"><span class="tocnumber">2.3</span> <span class="toctext">Passing token groups to the macro</span></a></li>
</ul>
</li>
</ul>
</td></tr></tbody></table>
<p><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
</p>
<a name="Expression_level_extensions"></a><h2> Expression level extensions </h2>
<p>We have mainly focused on the ability of extending the basic syntactic entity in Nemerle, which is the expression. 
</p><p>The new rules of parsing are triggered by the set of user
definable distinguished keywords and operators. When the parser
encounters one of those at the valid position of expression beginning,
then it executes a special parsing procedure for syntax extension
related to the distinguished token.
</p><p>All syntax extensions are specified by <a href="#chunk-Macros" title="Macros">macro</a>
definitions. Each macro can optionally have syntax definition, which
describes how given macro should be called when the syntax occurs in
program. For example
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">macro</span> while_macro <span style="color: rgb(0, 0, 0);">(</span>cond, body<span style="color: rgb(0, 0, 0);">)</span> 
<span style="color: rgb(6, 0, 255);">syntax</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"while"</span>, <span style="color: rgb(128, 128, 128);">"("</span>, cond, <span style="color: rgb(128, 128, 128);">")"</span>, body<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
  &lt;<span style="color: rgb(0, 0, 0);">[</span> 
    <span style="color: rgb(6, 0, 255);">def</span> loop <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
      <span style="color: rgb(6, 0, 255);">when</span> <span style="color: rgb(0, 0, 0);">(</span>$cond<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span> 
        $body; 
        loop <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span> 
      <span style="color: rgb(0, 0, 0);">}</span>
    <span style="color: rgb(0, 0, 0);">}</span>
    loop <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
  <span style="color: rgb(0, 0, 0);">]</span>&gt;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>creates a macro introducing <i>while</i> loop construct and syntax to the language.
</p>
<a name="Raw_token_extensions"></a><h2> Raw token extensions </h2>
<p>Nemerle has a very powerful method for introducing virtually
arbitrary syntax into language. It allows for specifying that given
part of program input will not be interpreted by main Nemerle parser,
but will be passed in easy to use representation to some macro.
</p>
<a name="The_parentheses_tree_concept"></a><h3> The <i>parentheses tree</i> concept </h3>
<p>The parser and all syntax extensions operate on token streams
created by the lexer and the so-called pre-parse stage. The lexing
phase simply transforms program text into a stream of tokens (like
identifiers, numbers, operators, distinguished keywords, etc.). </p><p>The next phase groups this stream into a tree of parentheses. We have distinguished four types of them (<b>{} () [] &lt;[ ]&gt;</b>).
Tokens inside those parentheses are also divided into groups separated
by special separator tokens. For example the following program fragment
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">fun</span> f <span style="color: rgb(0, 0, 0);">(</span>x&nbsp;: <span style="color: rgb(255, 0, 0);">string</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">def</span> y = <span style="color: rgb(0, 0, 0);">System</span>.Int32.Parse <span style="color: rgb(0, 0, 0);">(</span>x<span style="color: rgb(0, 0, 0);">)</span>;
  y + <span style="color: rgb(255, 0, 0);">1</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>is after the pre-parse stage represented as the token tree
</p>
<pre>  <b>[</b> fun <i>,</i> f <i>,</i> <b>(</b> <b>[</b> x <i>,</i> ':' <i>,</i> string <b>]</b> <b>)</b> <i>,</i> <b>{</b>
    <b>[</b> def <i>,</i> y <i>,</i> '=' <i>,</i> System <i>,</i> '.' <i>,</i> Int32 <i>,</i> '.' <i>,</i> Parse <i>,</i> <b>(</b> <b>[</b> x <b>]</b> <b>)</b> <b>]</b> <i>,</i>
    <b>[</b> y <i>,</i> '+' <i>,</i> 1 <b>]</b>
  <b>}</b> <b>]</b>
</pre>
<p>where matched parentheses groups are distinguished with <b>() {} []</b>  and their elements are separated with <i>,</i>. Note that groups like <b>()</b> and <b>{}</b> contain tokens enclosed by <b>[]</b>, which represents loose token groups - divisions of tokens split by separators (<b>,</b> for <b>() []</b> and <b>;</b> for <b>{} &lt;[ ]&gt;</b>).
</p>
<a name="Parentheses_tokens"></a><h3> Parentheses tokens </h3>
<p>So, according to the description above we have following kinds of
special tokens, which represents whole fragments of unparsed code:
</p>
<ul><li>Token.BracesGroup - for <b>{ }</b>
</li><li>Token.RoundGroup - for <b>( )</b>
</li><li>Token.SquareGroup - for <b>[ ]</b>
</li><li>Token.QuoteGroup - for <b>&lt;[ ]&gt;</b>, used in macro code quotation 
</li><li>Token.LooseGroup - list of tokens grouped inside one of above
brackets and separated by separator token specific for each of bracket
kinds
</li></ul>
<p>All the available tokens produced by lexer can be viewed <a href="http://nemerle.org/svn/nemerle/trunk/ncc/parsing/Lexer.n" class="external text" title="http://nemerle.org/svn/nemerle/trunk/ncc/parsing/Lexer.n">here</a>
</p>
<a name="Passing_token_groups_to_the_macro"></a><h3> Passing token groups to the macro </h3>
<p>Those raw grouping tokens can passed as a parameter of macro. We simply have to name it when specifying macro parameter:
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">macro</span> BuildXml <span style="color: rgb(0, 0, 0);">(</span>group&nbsp;: Token<span style="color: rgb(0, 0, 0);">)</span> 
<span style="color: rgb(6, 0, 255);">syntax</span> <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"xml"</span>, group<span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">{</span>
  ...
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>in code, where such a macro was imported we can use the new syntax:
</p>
<pre class="nemerle">foo <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span> <span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">def</span> doc = xml <span style="color: rgb(0, 0, 0);">(</span>&lt;node name=<span style="color: rgb(128, 128, 128);">"foo"</span>&gt;My name <span style="color: rgb(0, 128, 0);">is</span> foo&lt;/node&gt;<span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(0, 128, 128); font-style: italic;">// macro produced some XmlNode for us, we can use it</span>
  print <span style="color: rgb(0, 0, 0);">(</span>doc.InnerXml<span style="color: rgb(0, 0, 0);">)</span>; 
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>Inside such macro we can use our own specialized parser. For example
some small domain specific language can be embedded easily inside
Nemerle program provided a simple syntax extension.
</p>
<!-- Saved in parser cache with key wiki:pcache:idhash:739-0!1!0!0!!en!2 and timestamp 20060121191630 -->
<a name="chunk-Macro_tips"></a>
	  	  <h1 class="firstHeading">Macro tips</h1>
	    	    	    <!-- start content -->
	    <p>Some quick notes about using macros and quotations. This should really be merged with 
<a href="http://nemerle.org/macros.html" class="external text" title="http://nemerle.org/macros.html">macros' documentation page</a>,
but it will wait, because our parsetree structure is going to be
changed soon and this will also impact quotations (simplyfiy them) a
lot.
</p>
<a name="Quotations"></a><h2> Quotations </h2>
<p>For best reference of how to write quotations, take a look at algorithm used to translate them in <a href="http://nemerle.org/svn/nemerle/trunk/ncc/typing/Macros.n" class="external text" title="http://nemerle.org/svn/nemerle/trunk/ncc/typing/Macros.n">the sources</a>. This code is quite self explaining (at least if you just need to know how to write quotations).
</p>
<a name="Match_cases"></a><h3> Match cases </h3>
<p>So first, why can't I write 
</p>
<pre>&lt;[ | Some (x) =&gt; x ]&gt; 
</pre>
<p>Unfortunately 
</p>
<pre>| Some (x) =&gt; x 
</pre>
<p>is a match case, not an expression, and standard quotation is used
by default for expressions. To make a quoted match case, you must
simply add the <tt>case:</tt> target to the quotation. So it would finally look like 
</p>
<pre>&lt;[ case: | Some (x) =&gt; x ]&gt; 
</pre>
<p>Unfortunately parsetree is not yet unified enough to look very consistent and <tt> try </tt> statement use different syntax for quotations. You write
</p>
<pre>&lt;[ try $body catch { $exn&nbsp;: $exn_ty =&gt; $handler } ]&gt; 
</pre>
<p>This quotation allows only one handler in catch, but you can nest others in body of try block.
</p>
<a name="Compiler_API_available_from_macros"></a><h2> Compiler API available from macros </h2>
<p>Macros are arbitrary functions and they can reference any external
classes. It is sometimes also useful to use Nemerle compiler API from
withing a macro. It is usually done using two methods
</p>
<ul><li>Using static helper functions from <i>Nemerle.Compiler</i> namespace
</li><li>Using the instance of typer to make more advanced things, like
typing some code fragment, asking for defined local variables in
current scope, etc.
</li></ul>
<p>The second operation requires obtaining an instance of <i>Nemerle.Compiler.Typer</i>
within a macro. Actually, every macro has it as a hidden parameter (we
just didn't want to pollute macros syntax with this parameter, because
it is rarely used) and it can be obtained using <i>Nemerle.Macros.ImplicitCTX ()</i> function (it is a macro returning the hidden parameter). 
</p><p>Consider following code:
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">macro</span> print_visible_vars <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">def</span> locals = <span style="color: rgb(0, 0, 0);">Nemerle</span>.Macros.ImplicitCTX <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>.GetLocals <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(6, 0, 255);">def</span> amount = locals.Fold <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(255, 0, 0);">0</span>, <span style="color: rgb(6, 0, 255);">fun</span> <span style="color: rgb(0, 0, 0);">(</span>n&nbsp;: Name, loc&nbsp;: LocalValue, acc<span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">{</span>
    <span style="color: rgb(0, 0, 0);">System</span>.Console.WriteLine <span style="color: rgb(0, 0, 0);">(</span>$<span style="color: rgb(128, 128, 128);">"var $(n.Id) is visible"</span><span style="color: rgb(0, 0, 0);">)</span>;
    acc + <span style="color: rgb(255, 0, 0);">1</span>
  <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(0, 0, 0);">System</span>.Console.WriteLine <span style="color: rgb(0, 0, 0);">(</span>$<span style="color: rgb(128, 128, 128);">"seen $amount variables"</span><span style="color: rgb(0, 0, 0);">)</span>;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>This is the way how you can get some compiler's internals for your
own usage. Feel free to ask for new useful methods to be created in
compiler if you need them.
</p>
<!-- Saved in parser cache with key wiki:pcache:idhash:729-0!1!0!0!!en!2 and timestamp 20060121191631 -->
<a name="chunk-Defining_types_from_inside_macros"></a>
	  	  <h1 class="firstHeading">Defining types from inside macros</h1>
	    	    	    <!-- start content -->
	    <a name="Basics"></a><h2> Basics </h2>
<p>Macros can define new types, as well as add members to existing types.
</p><p>There are two ways of defining types, you can either:
</p>
<ul><li>define a nested type inside some other type (using <tt>DefineNestedType</tt> method of the <tt>TypeBuilder</tt>) or
</li><li>define a new top level type (using <tt>Define</tt> method of the <tt>GlobalEnv</tt> class).
</li></ul>
<p>Both methods take the same argument -- just a single quotation of the type
<tt>decl</tt>. <tt>TypeBuilder</tt> object can be obtained from a parameter
of a macro-on-declaration or from <tt>Nemerle.Macros.ImplicitCTX
().CurrentTypeBuilder</tt>. Current <tt>GlobalEnv</tt> is available in
<tt>Nemerle.Macros.ImplicitCTX ().Env</tt>.
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">macro</span> BuildClass <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">def</span> ctx = <span style="color: rgb(0, 0, 0);">Nemerle</span>.Macros.ImplicitCTX <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(6, 0, 255);">def</span> builder = ctx.Env.Define <span style="color: rgb(0, 0, 0);">(</span>&lt;<span style="color: rgb(0, 0, 0);">[</span> decl:
    <span style="color: rgb(6, 0, 255);">internal</span> <span style="color: rgb(255, 0, 0);">class</span> FooBar
    <span style="color: rgb(0, 0, 0);">{</span>
      <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">static</span> SomeMethod <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
      <span style="color: rgb(0, 0, 0);">{</span>
        <span style="color: rgb(0, 0, 0);">System</span>.Console.WriteLine <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"Hello world"</span><span style="color: rgb(0, 0, 0);">)</span>;
      <span style="color: rgb(0, 0, 0);">}</span>
    <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(0, 0, 0);">]</span>&gt;<span style="color: rgb(0, 0, 0);">)</span>;
&nbsp;
  builder.Compile <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
&nbsp;
  &lt;<span style="color: rgb(0, 0, 0);">[</span> FooBar.SomeMethod <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>This macro will add a new class inside the current namespace,
the class will be named <tt>FooBar</tt>. The macro will return a call to
a function inside this class. That is this code:
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">module</span> Some <span style="color: rgb(0, 0, 0);">{</span>
  Main <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    BuildClass <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>will print the famous message.
</p><p>One gotcha here is that the following code:
</p>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">module</span> Some <span style="color: rgb(0, 0, 0);">{</span>
  Main <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
  <span style="color: rgb(0, 0, 0);">{</span>
    BuildClass <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
    BuildClass <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(0, 0, 0);">}</span>
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>will give redefinition error instead of a second message. Macros do not
guarantee hygiene of global symbols.
</p><p>Another gotcha is the <tt>builder.Compile()</tt> call. If you forget it,
then the compiler will throw ICE when the macro is used.
</p>
<a name="Longer_example"></a><h2> Longer example </h2>
<pre class="nemerle"><span style="color: rgb(6, 0, 255);">macro</span> BuildClass <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>
<span style="color: rgb(0, 0, 0);">{</span>
  <span style="color: rgb(6, 0, 255);">def</span> ctx = <span style="color: rgb(0, 0, 0);">Nemerle</span>.Macros.ImplicitCTX <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
  <span style="color: rgb(6, 0, 255);">def</span> builder = ctx.Env.Define <span style="color: rgb(0, 0, 0);">(</span>&lt;<span style="color: rgb(0, 0, 0);">[</span> decl:
    <span style="color: rgb(6, 0, 255);">internal</span> <span style="color: rgb(255, 0, 0);">class</span> FooBar
    <span style="color: rgb(0, 0, 0);">{</span>
      <span style="color: rgb(6, 0, 255);">public</span> <span style="color: rgb(6, 0, 255);">static</span> SomeMethod <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>&nbsp;: <span style="color: rgb(6, 0, 255);">void</span>
      <span style="color: rgb(0, 0, 0);">{</span>
        <span style="color: rgb(0, 0, 0);">System</span>.Console.WriteLine <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(128, 128, 128);">"Hello world"</span><span style="color: rgb(0, 0, 0);">)</span>;
      <span style="color: rgb(0, 0, 0);">}</span>
    <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(0, 0, 0);">]</span>&gt;<span style="color: rgb(0, 0, 0);">)</span>;
&nbsp;
  builder.Define <span style="color: rgb(0, 0, 0);">(</span>&lt;<span style="color: rgb(0, 0, 0);">[</span> decl: foo&nbsp;: <span style="color: rgb(255, 0, 0);">int</span>; <span style="color: rgb(0, 0, 0);">]</span>&gt;<span style="color: rgb(0, 0, 0);">)</span>;
  builder.Compile <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
  builder.CannotFinalize = <span style="color: rgb(6, 0, 255);">true</span>;
&nbsp;
  builder.Define <span style="color: rgb(0, 0, 0);">(</span>&lt;<span style="color: rgb(0, 0, 0);">[</span> decl: 
    <span style="color: rgb(6, 0, 255);">public</span> Foo&nbsp;: <span style="color: rgb(255, 0, 0);">int</span> 
    <span style="color: rgb(0, 0, 0);">{</span>
      get <span style="color: rgb(0, 0, 0);">{</span> foo <span style="color: rgb(0, 0, 0);">}</span> 
    <span style="color: rgb(0, 0, 0);">}</span> 
  <span style="color: rgb(0, 0, 0);">]</span>&gt;<span style="color: rgb(0, 0, 0);">)</span>;
&nbsp;
  <span style="color: rgb(6, 0, 255);">def</span> nested_builder = builder.DefineNestedType <span style="color: rgb(0, 0, 0);">(</span>&lt;<span style="color: rgb(0, 0, 0);">[</span> decl:
    <span style="color: rgb(6, 0, 255);">internal</span> <span style="color: rgb(255, 0, 0);">class</span> SomeClass <span style="color: rgb(0, 0, 0);">{</span> <span style="color: rgb(0, 0, 0);">}</span>
  <span style="color: rgb(0, 0, 0);">]</span>&gt;<span style="color: rgb(0, 0, 0);">)</span>;
  nested_builder.Compile <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span>;
  
  builder.CannotFinalize = <span style="color: rgb(6, 0, 255);">false</span>;
&nbsp;
  &lt;<span style="color: rgb(0, 0, 0);">[</span> FooBar <span style="color: rgb(0, 0, 0);">(</span><span style="color: rgb(0, 0, 0);">)</span> <span style="color: rgb(0, 0, 0);">]</span>&gt;
<span style="color: rgb(0, 0, 0);">}</span></pre>
<p>The <tt>GlobalEnv.Define</tt> (as well as <tt>TypeBuilder.Compile</tt>)
return a fresh <tt>TypeBuilder</tt> object, that can be used to add new
members using the <tt>Define</tt> and <tt>DefineNestedType</tt> methods.
There is also a <tt>DefineAndReturn</tt> method, that works much like
<tt>Define</tt>, but returns the added member (as <tt>option [IMember]</tt>).
</p><p>As you can see, you can add new member to already built class, but this needs
additional hassle with the <tt>CannotFinalize</tt> property.
</p>
<a name="Stages_of_TypeBuilder"></a><h2> Stages of TypeBuilder </h2>
<p>To understand the <tt>CannotFinalize</tt> stuff properly we need to talk
a bit about the internals of the compiler.
</p><p>During compilation it first scans through the entire program to look for
global definitions. Then there are several passes dealing with them.
You can plug macros in most places of this process. Once the global
iteration passes are done, the compiler proceeds with typing and code
generation for each method in turn. Then the regular macros are called.
</p><p>Now we want to add new types during typing. However the passes setting
up various things in types have already been run.
</p><p>Therefore the <tt>Define/DefineNestedType</tt> call a few functions right
after the type is created. The most important are:
</p>
<ul><li>setting the <tt>CannotFinalize</tt> property to true
</li><li>resolving type names used in definitions
</li><li>adding default constructor if no constructor was found
</li><li>running any macros attached to the type and definitions within it
</li></ul>
<p>Next the <tt>Compile()</tt> call does a few other things:
</p>
<ul><li>set <tt>CannotFinalize</tt> property to false
</li><li>check implemented interfaces (that is, if you declared that
you will implement some interface and failed to provide implementation
for some methods, you will get an error here)
</li><li>add SRE declarations (this in particular means that the members of this type can be used during expression typing <b>only</b> after Compile() is called)
</li><li>queue compilation of methods inside the type (the compilation
cannot occur just at the moment Compile() is called, because we support
only one method compilation at a time, and Compile() can be called
during compilation of some method)
</li></ul>
<p>Now about the <tt>CannotFinalize</tt> property. If it's true, the type won't 
be finalized, that is finished up. This can happen if it gets to regular typer
queues, so if you want to add members after Compile(), better set it to true.
But don't forget to set it to false before the end of the compilation, 
otherwise you'll get an ICE.
</p>
<!-- Saved in parser cache with key wiki:pcache:idhash:1020-0!1!0!0!!en!2 and timestamp 20060121125009 -->
</body></html>